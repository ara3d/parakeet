// DO NOT EDIT: Autogenerated file created on 2024-06-29 2:12:45 AM. 
using System;
using System.Linq;

namespace Ara3D.Parakeet.Cst.MustacheGrammarNameSpace
{
    /// <summary>This interface exists to make it easy to auto-generate type switches</summary>
    public interface IMustacheCstNode { }

    /// <summary>
    /// Rule = Block ::= ((InvertedSection|Section|Comment|Partial|Variable|UnescapedVariable|PlainText)+(Spaces)?)
    /// Nodes = (InvertedSection|Section|Comment|Partial|Variable|UnescapedVariable|PlainText)
    /// </summary>
    public class CstBlock : CstNodeChoice, IMustacheCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Block;
        public CstBlock(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstInvertedSection> InvertedSection => new CstNodeFilter<CstInvertedSection> (Children);
        public CstNodeFilter<CstSection> Section => new CstNodeFilter<CstSection> (Children);
        public CstNodeFilter<CstComment> Comment => new CstNodeFilter<CstComment> (Children);
        public CstNodeFilter<CstPartial> Partial => new CstNodeFilter<CstPartial> (Children);
        public CstNodeFilter<CstVariable> Variable => new CstNodeFilter<CstVariable> (Children);
        public CstNodeFilter<CstUnescapedVariable> UnescapedVariable => new CstNodeFilter<CstUnescapedVariable> (Children);
        public CstNodeFilter<CstPlainText> PlainText => new CstNodeFilter<CstPlainText> (Children);
    }

    /// <summary>
    /// Rule = Comment ::= ((Start+'!'+_RECOVER_+(Space)*+Key+End)+(Spaces)?)
    /// Nodes = Key
    /// </summary>
    public class CstComment : CstNode, IMustacheCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Comment;
        public CstComment(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstKey> Key => new CstNodeFilter<CstKey> (Children);
    }

    /// <summary>
    /// Rule = Content ::= ((Block)*+(Spaces)?)
    /// Nodes = (Block)*
    /// </summary>
    public class CstContent : CstNode, IMustacheCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Content;
        public CstContent(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstBlock> Block => new CstNodeFilter<CstBlock> (Children);
    }

    /// <summary>
    /// Rule = Document ::= (Content+(Spaces)?)
    /// Nodes = Content
    /// </summary>
    public class CstDocument : CstNode, IMustacheCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Document;
        public CstDocument(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstContent> Content => new CstNodeFilter<CstContent> (Children);
    }

    /// <summary>
    /// Rule = EndSection ::= ((Start+'/'+_RECOVER_+(Space)*+Key+End)+(Spaces)?)
    /// Nodes = Key
    /// </summary>
    public class CstEndSection : CstNode, IMustacheCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.EndSection;
        public CstEndSection(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstKey> Key => new CstNodeFilter<CstKey> (Children);
    }

    /// <summary>
    /// Rule = Identifier ::= ((IdentifierFirstChar+(IdentifierChar)*)+(Spaces)?)
    /// Nodes = 
    /// </summary>
    public class CstIdentifier : CstNodeLeaf, IMustacheCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Identifier;
        public CstIdentifier(ILocation location, string text) : base(location, text) { }
    }

    /// <summary>
    /// Rule = InvertedSection ::= ((StartInvertedSection+_RECOVER_+Content+EndSection)+(Spaces)?)
    /// Nodes = (StartInvertedSection+Content+EndSection)
    /// </summary>
    public class CstInvertedSection : CstNodeSequence, IMustacheCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.InvertedSection;
        public CstInvertedSection(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstStartInvertedSection> StartInvertedSection => new CstNodeFilter<CstStartInvertedSection> (Children);
        public CstNodeFilter<CstContent> Content => new CstNodeFilter<CstContent> (Children);
        public CstNodeFilter<CstEndSection> EndSection => new CstNodeFilter<CstEndSection> (Children);
    }

    /// <summary>
    /// Rule = Key ::= (((!(End)+AnyChar))*+(Spaces)?)
    /// Nodes = 
    /// </summary>
    public class CstKey : CstNodeLeaf, IMustacheCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Key;
        public CstKey(ILocation location, string text) : base(location, text) { }
    }

    /// <summary>
    /// Rule = Partial ::= ((Start+'>'+_RECOVER_+(Space)*+Key+End)+(Spaces)?)
    /// Nodes = Key
    /// </summary>
    public class CstPartial : CstNode, IMustacheCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Partial;
        public CstPartial(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstKey> Key => new CstNodeFilter<CstKey> (Children);
    }

    /// <summary>
    /// Rule = PlainText ::= (((!((Start|EndOfInput))+AnyChar))*+(Spaces)?)
    /// Nodes = 
    /// </summary>
    public class CstPlainText : CstNodeLeaf, IMustacheCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.PlainText;
        public CstPlainText(ILocation location, string text) : base(location, text) { }
    }

    /// <summary>
    /// Rule = RestOfLine ::= ((((SpaceOrTab)*+NewLine)|EndOfInput)+(Spaces)?)
    /// Nodes = 
    /// </summary>
    public class CstRestOfLine : CstNodeLeaf, IMustacheCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.RestOfLine;
        public CstRestOfLine(ILocation location, string text) : base(location, text) { }
    }

    /// <summary>
    /// Rule = Section ::= ((StartSection+_RECOVER_+Content+EndSection)+(Spaces)?)
    /// Nodes = (StartSection+Content+EndSection)
    /// </summary>
    public class CstSection : CstNodeSequence, IMustacheCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Section;
        public CstSection(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstStartSection> StartSection => new CstNodeFilter<CstStartSection> (Children);
        public CstNodeFilter<CstContent> Content => new CstNodeFilter<CstContent> (Children);
        public CstNodeFilter<CstEndSection> EndSection => new CstNodeFilter<CstEndSection> (Children);
    }

    /// <summary>
    /// Rule = StartInvertedSection ::= ((Start+'^'+_RECOVER_+(Space)*+Key+End+RestOfLine)+(Spaces)?)
    /// Nodes = (Key+RestOfLine)
    /// </summary>
    public class CstStartInvertedSection : CstNodeSequence, IMustacheCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.StartInvertedSection;
        public CstStartInvertedSection(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstKey> Key => new CstNodeFilter<CstKey> (Children);
        public CstNodeFilter<CstRestOfLine> RestOfLine => new CstNodeFilter<CstRestOfLine> (Children);
    }

    /// <summary>
    /// Rule = StartSection ::= ((Start+'#'+_RECOVER_+(Space)*+Key+End+RestOfLine)+(Spaces)?)
    /// Nodes = (Key+RestOfLine)
    /// </summary>
    public class CstStartSection : CstNodeSequence, IMustacheCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.StartSection;
        public CstStartSection(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstKey> Key => new CstNodeFilter<CstKey> (Children);
        public CstNodeFilter<CstRestOfLine> RestOfLine => new CstNodeFilter<CstRestOfLine> (Children);
    }

    /// <summary>
    /// Rule = UnescapedVariable ::= (((Start+'{'+_RECOVER_+(Space)*+Key+End+('}')?)|(Start+'&'+_RECOVER_+(Space)*+Key+End))+(Spaces)?)
    /// Nodes = (Key|Key)
    /// </summary>
    public class CstUnescapedVariable : CstNodeChoice, IMustacheCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.UnescapedVariable;
        public CstUnescapedVariable(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstKey> Key => new CstNodeFilter<CstKey> (Children);
    }

    /// <summary>
    /// Rule = Variable ::= ((Start+!([\x21\x23\x26\x2F<^\x7B])+_RECOVER_+(Space)*+Key+End)+(Spaces)?)
    /// Nodes = Key
    /// </summary>
    public class CstVariable : CstNode, IMustacheCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Variable;
        public CstVariable(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstKey> Key => new CstNodeFilter<CstKey> (Children);
    }

}
