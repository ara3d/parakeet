// DO NOT EDIT: Autogenerated file created on 2024-06-29 2:12:45 AM. 
using System;
using System.Linq;

namespace Ara3D.Parakeet.Cst.PlatoGrammarNameSpace
{
    /// <summary>This interface exists to make it easy to auto-generate type switches</summary>
    public interface IPlatoCstNode { }

    /// <summary>
    /// Rule = ArrayExpression ::= (('['+WS+_UNKNOWN_+(((Expression+WS+((Comma+Expression+WS))*)+(Comma)?))?+WS+']'+WS)+WS)
    /// Nodes = (Expression)*
    /// </summary>
    public class CstArrayExpression : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.ArrayExpression;
        public CstArrayExpression(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Rule = ArrayInitializationValue ::= (('{'+WS+_UNKNOWN_+(((Expression+WS+((Comma+Expression+WS))*)+(Comma)?))?+WS+'}'+WS)+WS)
    /// Nodes = (Expression)*
    /// </summary>
    public class CstArrayInitializationValue : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.ArrayInitializationValue;
        public CstArrayInitializationValue(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Rule = ArrayRankSpecifier ::= (('['+WS+_UNKNOWN_+(Comma)*+WS+']'+WS)+WS)
    /// Nodes = 
    /// </summary>
    public class CstArrayRankSpecifier : CstNodeLeaf, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.ArrayRankSpecifier;
        public CstArrayRankSpecifier(ILocation location, string text) : base(location, text) { }
    }

    /// <summary>
    /// Rule = ArrayRankSpecifiers ::= ((ArrayRankSpecifier)*+WS)
    /// Nodes = (ArrayRankSpecifier)*
    /// </summary>
    public class CstArrayRankSpecifiers : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.ArrayRankSpecifiers;
        public CstArrayRankSpecifiers(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstArrayRankSpecifier> ArrayRankSpecifier => new CstNodeFilter<CstArrayRankSpecifier> (Children);
    }

    /// <summary>
    /// Rule = ArraySizeSpecifier ::= (('['+WS+_UNKNOWN_+Expression+WS+']'+WS)+WS)
    /// Nodes = Expression
    /// </summary>
    public class CstArraySizeSpecifier : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.ArraySizeSpecifier;
        public CstArraySizeSpecifier(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Rule = AsOperation ::= ((Keyword('as')+_RECOVER_+TypeExpr+(Identifier)?)+WS)
    /// Nodes = (TypeExpr+(Identifier)?)
    /// </summary>
    public class CstAsOperation : CstNodeSequence, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.AsOperation;
        public CstAsOperation(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstTypeExpr> TypeExpr => new CstNodeFilter<CstTypeExpr> (Children);
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
    }

    /// <summary>
    /// Rule = BinaryLiteral ::= (("0b"|("0B"+(BinDigit)++(IntegerSuffix)?))+WS)
    /// Nodes = 
    /// </summary>
    public class CstBinaryLiteral : CstNodeLeaf, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.BinaryLiteral;
        public CstBinaryLiteral(ILocation location, string text) : base(location, text) { }
    }

    /// <summary>
    /// Rule = BinaryOperation ::= ((!("=>")+BinaryOperator+_RECOVER_+Expression)+WS)
    /// Nodes = (BinaryOperator+Expression)
    /// </summary>
    public class CstBinaryOperation : CstNodeSequence, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.BinaryOperation;
        public CstBinaryOperation(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstBinaryOperator> BinaryOperator => new CstNodeFilter<CstBinaryOperator> (Children);
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Rule = BinaryOperator ::= ((Symbol('>>>=')|Symbol('and')|Symbol('>>=')|Symbol('<<=')|Symbol('&&=')|Symbol('||=')|Symbol('or')|Symbol('<<')|Symbol('&&')|Symbol('||')|Symbol('+=')|Symbol('-=')|Symbol('*=')|Symbol('/=')|Symbol('%=')|Symbol('&=')|Symbol('|=')|Symbol('^=')|Symbol('<=')|Symbol('>=')|Symbol('==')|Symbol('!=')|Symbol('+')|Symbol('-')|Symbol('*')|Symbol('/')|Symbol('%')|Symbol('&')|Symbol('|')|Symbol('^')|Symbol('=')|Symbol('<')|Symbol('>'))+WS)
    /// Nodes = 
    /// </summary>
    public class CstBinaryOperator : CstNodeLeaf, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.BinaryOperator;
        public CstBinaryOperator(ILocation location, string text) : base(location, text) { }
    }

    /// <summary>
    /// Rule = BooleanLiteral ::= ((Keyword('true')|Keyword('false'))+WS)
    /// Nodes = 
    /// </summary>
    public class CstBooleanLiteral : CstNodeLeaf, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.BooleanLiteral;
        public CstBooleanLiteral(ILocation location, string text) : base(location, text) { }
    }

    /// <summary>
    /// Rule = BracedTokenGroup ::= (('{'+WS+_UNKNOWN_+Token+WS+'}'+WS)+WS)
    /// Nodes = ((TypeKeyword+TypeName)|(FieldName+TypeName+(TypeParametersToken)?)|(FunctionName+ParameterName+TypeName+(TypeParametersToken)?+((ParameterName+TypeName+(TypeParametersToken)?))*+((TypeName+(TypeParametersToken)?))?)|Separator|Delimiter|Operator|Identifier|HexLiteral|BinaryLiteral|FloatLiteral|IntegerLiteral|StringLiteral|CharLiteral|BooleanLiteral|NullLiteral|Unknown)
    /// </summary>
    public class CstBracedTokenGroup : CstNodeChoice, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.BracedTokenGroup;
        public CstBracedTokenGroup(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstTypeKeyword> TypeKeyword => new CstNodeFilter<CstTypeKeyword> (Children);
        public CstNodeFilter<CstTypeName> TypeName => new CstNodeFilter<CstTypeName> (Children);
        public CstNodeFilter<CstFieldName> FieldName => new CstNodeFilter<CstFieldName> (Children);
        public CstNodeFilter<CstTypeParametersToken> TypeParametersToken => new CstNodeFilter<CstTypeParametersToken> (Children);
        public CstNodeFilter<CstFunctionName> FunctionName => new CstNodeFilter<CstFunctionName> (Children);
        public CstNodeFilter<CstParameterName> ParameterName => new CstNodeFilter<CstParameterName> (Children);
        public CstNodeFilter<CstSeparator> Separator => new CstNodeFilter<CstSeparator> (Children);
        public CstNodeFilter<CstDelimiter> Delimiter => new CstNodeFilter<CstDelimiter> (Children);
        public CstNodeFilter<CstOperator> Operator => new CstNodeFilter<CstOperator> (Children);
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
        public CstNodeFilter<CstHexLiteral> HexLiteral => new CstNodeFilter<CstHexLiteral> (Children);
        public CstNodeFilter<CstBinaryLiteral> BinaryLiteral => new CstNodeFilter<CstBinaryLiteral> (Children);
        public CstNodeFilter<CstFloatLiteral> FloatLiteral => new CstNodeFilter<CstFloatLiteral> (Children);
        public CstNodeFilter<CstIntegerLiteral> IntegerLiteral => new CstNodeFilter<CstIntegerLiteral> (Children);
        public CstNodeFilter<CstStringLiteral> StringLiteral => new CstNodeFilter<CstStringLiteral> (Children);
        public CstNodeFilter<CstCharLiteral> CharLiteral => new CstNodeFilter<CstCharLiteral> (Children);
        public CstNodeFilter<CstBooleanLiteral> BooleanLiteral => new CstNodeFilter<CstBooleanLiteral> (Children);
        public CstNodeFilter<CstNullLiteral> NullLiteral => new CstNodeFilter<CstNullLiteral> (Children);
        public CstNodeFilter<CstUnknown> Unknown => new CstNodeFilter<CstUnknown> (Children);
    }

    /// <summary>
    /// Rule = BracketedTokenGroup ::= (('['+WS+_UNKNOWN_+Token+WS+']'+WS)+WS)
    /// Nodes = ((TypeKeyword+TypeName)|(FieldName+TypeName+(TypeParametersToken)?)|(FunctionName+ParameterName+TypeName+(TypeParametersToken)?+((ParameterName+TypeName+(TypeParametersToken)?))*+((TypeName+(TypeParametersToken)?))?)|Separator|Delimiter|Operator|Identifier|HexLiteral|BinaryLiteral|FloatLiteral|IntegerLiteral|StringLiteral|CharLiteral|BooleanLiteral|NullLiteral|Unknown)
    /// </summary>
    public class CstBracketedTokenGroup : CstNodeChoice, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.BracketedTokenGroup;
        public CstBracketedTokenGroup(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstTypeKeyword> TypeKeyword => new CstNodeFilter<CstTypeKeyword> (Children);
        public CstNodeFilter<CstTypeName> TypeName => new CstNodeFilter<CstTypeName> (Children);
        public CstNodeFilter<CstFieldName> FieldName => new CstNodeFilter<CstFieldName> (Children);
        public CstNodeFilter<CstTypeParametersToken> TypeParametersToken => new CstNodeFilter<CstTypeParametersToken> (Children);
        public CstNodeFilter<CstFunctionName> FunctionName => new CstNodeFilter<CstFunctionName> (Children);
        public CstNodeFilter<CstParameterName> ParameterName => new CstNodeFilter<CstParameterName> (Children);
        public CstNodeFilter<CstSeparator> Separator => new CstNodeFilter<CstSeparator> (Children);
        public CstNodeFilter<CstDelimiter> Delimiter => new CstNodeFilter<CstDelimiter> (Children);
        public CstNodeFilter<CstOperator> Operator => new CstNodeFilter<CstOperator> (Children);
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
        public CstNodeFilter<CstHexLiteral> HexLiteral => new CstNodeFilter<CstHexLiteral> (Children);
        public CstNodeFilter<CstBinaryLiteral> BinaryLiteral => new CstNodeFilter<CstBinaryLiteral> (Children);
        public CstNodeFilter<CstFloatLiteral> FloatLiteral => new CstNodeFilter<CstFloatLiteral> (Children);
        public CstNodeFilter<CstIntegerLiteral> IntegerLiteral => new CstNodeFilter<CstIntegerLiteral> (Children);
        public CstNodeFilter<CstStringLiteral> StringLiteral => new CstNodeFilter<CstStringLiteral> (Children);
        public CstNodeFilter<CstCharLiteral> CharLiteral => new CstNodeFilter<CstCharLiteral> (Children);
        public CstNodeFilter<CstBooleanLiteral> BooleanLiteral => new CstNodeFilter<CstBooleanLiteral> (Children);
        public CstNodeFilter<CstNullLiteral> NullLiteral => new CstNodeFilter<CstNullLiteral> (Children);
        public CstNodeFilter<CstUnknown> Unknown => new CstNodeFilter<CstUnknown> (Children);
    }

    /// <summary>
    /// Rule = BreakStatement ::= ((Keyword('break')+_RECOVER_+EOS)+WS)
    /// Nodes = 
    /// </summary>
    public class CstBreakStatement : CstNodeLeaf, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.BreakStatement;
        public CstBreakStatement(ILocation location, string text) : base(location, text) { }
    }

    /// <summary>
    /// Rule = CaseClause ::= (((Keyword('default')|(Keyword('case')+_RECOVER_+Expression))+Statement)+WS)
    /// Nodes = (Expression+Statement)
    /// </summary>
    public class CstCaseClause : CstNodeSequence, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.CaseClause;
        public CstCaseClause(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
        public CstNodeFilter<CstStatement> Statement => new CstNodeFilter<CstStatement> (Children);
    }

    /// <summary>
    /// Rule = CastExpression ::= (('('+WS+_UNKNOWN_+TypeExpr+WS+')'+WS+Expression)+WS)
    /// Nodes = (TypeExpr+Expression)
    /// </summary>
    public class CstCastExpression : CstNodeSequence, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.CastExpression;
        public CstCastExpression(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstTypeExpr> TypeExpr => new CstNodeFilter<CstTypeExpr> (Children);
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Rule = CatchClause ::= ((Keyword('catch')+_RECOVER_+'('+WS+_UNKNOWN_+VarDecl+WS+')'+WS+CompoundStatement)+WS)
    /// Nodes = (VarDecl+CompoundStatement)
    /// </summary>
    public class CstCatchClause : CstNodeSequence, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.CatchClause;
        public CstCatchClause(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstVarDecl> VarDecl => new CstNodeFilter<CstVarDecl> (Children);
        public CstNodeFilter<CstCompoundStatement> CompoundStatement => new CstNodeFilter<CstCompoundStatement> (Children);
    }

    /// <summary>
    /// Rule = CharLiteral ::= (('''+CharLiteralChar+''')+WS)
    /// Nodes = 
    /// </summary>
    public class CstCharLiteral : CstNodeLeaf, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.CharLiteral;
        public CstCharLiteral(ILocation location, string text) : base(location, text) { }
    }

    /// <summary>
    /// Rule = CompoundOrSimpleTypeExpr ::= ((CompoundTypeExpr|SimpleTypeExpr|TypeVar)+WS)
    /// Nodes = (CompoundTypeExpr|SimpleTypeExpr|TypeVar)
    /// </summary>
    public class CstCompoundOrSimpleTypeExpr : CstNodeChoice, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.CompoundOrSimpleTypeExpr;
        public CstCompoundOrSimpleTypeExpr(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstCompoundTypeExpr> CompoundTypeExpr => new CstNodeFilter<CstCompoundTypeExpr> (Children);
        public CstNodeFilter<CstSimpleTypeExpr> SimpleTypeExpr => new CstNodeFilter<CstSimpleTypeExpr> (Children);
        public CstNodeFilter<CstTypeVar> TypeVar => new CstNodeFilter<CstTypeVar> (Children);
    }

    /// <summary>
    /// Rule = CompoundStatement ::= (('{'+WS+_RECOVER_+(Statement)*+WS+'}'+WS)+WS)
    /// Nodes = (Statement)*
    /// </summary>
    public class CstCompoundStatement : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.CompoundStatement;
        public CstCompoundStatement(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstStatement> Statement => new CstNodeFilter<CstStatement> (Children);
    }

    /// <summary>
    /// Rule = CompoundTypeExpr ::= (('('+WS+_UNKNOWN_+(((TypeExpr+WS+((Comma+TypeExpr+WS))*)+(Comma)?))?+WS+')'+WS)+WS)
    /// Nodes = (TypeExpr)*
    /// </summary>
    public class CstCompoundTypeExpr : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.CompoundTypeExpr;
        public CstCompoundTypeExpr(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstTypeExpr> TypeExpr => new CstNodeFilter<CstTypeExpr> (Children);
    }

    /// <summary>
    /// Rule = Concept ::= ((Keyword('concept')+_RECOVER_+Identifier+TypeParameterList+ConstraintList+InheritsList+'{'+WS+_RECOVER_+(MethodDeclaration)*+WS+'}'+WS)+WS)
    /// Nodes = (Identifier+TypeParameterList+ConstraintList+InheritsList+(MethodDeclaration)*)
    /// </summary>
    public class CstConcept : CstNodeSequence, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Concept;
        public CstConcept(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
        public CstNodeFilter<CstTypeParameterList> TypeParameterList => new CstNodeFilter<CstTypeParameterList> (Children);
        public CstNodeFilter<CstConstraintList> ConstraintList => new CstNodeFilter<CstConstraintList> (Children);
        public CstNodeFilter<CstInheritsList> InheritsList => new CstNodeFilter<CstInheritsList> (Children);
        public CstNodeFilter<CstMethodDeclaration> MethodDeclaration => new CstNodeFilter<CstMethodDeclaration> (Children);
    }

    /// <summary>
    /// Rule = ConditionalMemberAccess ::= ((Symbol('?.')+Identifier)+WS)
    /// Nodes = Identifier
    /// </summary>
    public class CstConditionalMemberAccess : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.ConditionalMemberAccess;
        public CstConditionalMemberAccess(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
    }

    /// <summary>
    /// Rule = Constraint ::= ((Identifier+TypeAnnotation)+WS)
    /// Nodes = (Identifier+TypeAnnotation)
    /// </summary>
    public class CstConstraint : CstNodeSequence, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Constraint;
        public CstConstraint(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
        public CstNodeFilter<CstTypeAnnotation> TypeAnnotation => new CstNodeFilter<CstTypeAnnotation> (Children);
    }

    /// <summary>
    /// Rule = ConstraintList ::= (((Keyword('where')+_RECOVER_+(((Constraint+WS+((Comma+Constraint+WS))*)+(Comma)?))?))?+WS)
    /// Nodes = (Constraint)*
    /// </summary>
    public class CstConstraintList : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.ConstraintList;
        public CstConstraintList(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstConstraint> Constraint => new CstNodeFilter<CstConstraint> (Children);
    }

    /// <summary>
    /// Rule = ContinueStatement ::= ((Keyword('continue')+_RECOVER_+EOS)+WS)
    /// Nodes = 
    /// </summary>
    public class CstContinueStatement : CstNodeLeaf, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.ContinueStatement;
        public CstContinueStatement(ILocation location, string text) : base(location, text) { }
    }

    /// <summary>
    /// Rule = Default ::= ((Keyword('default')+_RECOVER_+(('('+WS+_UNKNOWN_+TypeExpr+WS+')'+WS))?)+WS)
    /// Nodes = (TypeExpr)?
    /// </summary>
    public class CstDefault : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Default;
        public CstDefault(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstTypeExpr> TypeExpr => new CstNodeFilter<CstTypeExpr> (Children);
    }

    /// <summary>
    /// Rule = Delimiter ::= ([\x28\x29\x5B\x5D\x7B\x7D]+WS)
    /// Nodes = 
    /// </summary>
    public class CstDelimiter : CstNodeLeaf, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Delimiter;
        public CstDelimiter(ILocation location, string text) : base(location, text) { }
    }

    /// <summary>
    /// Rule = DoWhileStatement ::= ((Keyword('do')+_RECOVER_+Statement+Keyword('while')+ParenthesizedExpression+EOS)+WS)
    /// Nodes = (Statement+ParenthesizedExpression)
    /// </summary>
    public class CstDoWhileStatement : CstNodeSequence, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.DoWhileStatement;
        public CstDoWhileStatement(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstStatement> Statement => new CstNodeFilter<CstStatement> (Children);
        public CstNodeFilter<CstParenthesizedExpression> ParenthesizedExpression => new CstNodeFilter<CstParenthesizedExpression> (Children);
    }

    /// <summary>
    /// Rule = ElseClause ::= ((Keyword('else')+_RECOVER_+Statement)+WS)
    /// Nodes = Statement
    /// </summary>
    public class CstElseClause : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.ElseClause;
        public CstElseClause(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstStatement> Statement => new CstNodeFilter<CstStatement> (Children);
    }

    /// <summary>
    /// Rule = Expression ::= (InnerExpression+WS)
    /// Nodes = InnerExpression
    /// </summary>
    public class CstExpression : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Expression;
        public CstExpression(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstInnerExpression> InnerExpression => new CstNodeFilter<CstInnerExpression> (Children);
    }

    /// <summary>
    /// Rule = ExpressionBody ::= ((Symbol('=>')+_RECOVER_+Expression+EOS)+WS)
    /// Nodes = Expression
    /// </summary>
    public class CstExpressionBody : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.ExpressionBody;
        public CstExpressionBody(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Rule = ExpressionStatement ::= ((Expression+_RECOVER_+EOS)+WS)
    /// Nodes = Expression
    /// </summary>
    public class CstExpressionStatement : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.ExpressionStatement;
        public CstExpressionStatement(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Rule = FieldDeclaration ::= ((Identifier+Symbol(':')+TypeExpr+EOS)+WS)
    /// Nodes = (Identifier+TypeExpr)
    /// </summary>
    public class CstFieldDeclaration : CstNodeSequence, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.FieldDeclaration;
        public CstFieldDeclaration(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
        public CstNodeFilter<CstTypeExpr> TypeExpr => new CstNodeFilter<CstTypeExpr> (Children);
    }

    /// <summary>
    /// Rule = FieldName ::= (Identifier+WS)
    /// Nodes = Identifier
    /// </summary>
    public class CstFieldName : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.FieldName;
        public CstFieldName(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
    }

    /// <summary>
    /// Rule = File ::= ((WS+(TopLevelDeclaration)*+_RECOVER_+EndOfInput)+WS)
    /// Nodes = (TopLevelDeclaration)*
    /// </summary>
    public class CstFile : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.File;
        public CstFile(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstTopLevelDeclaration> TopLevelDeclaration => new CstNodeFilter<CstTopLevelDeclaration> (Children);
    }

    /// <summary>
    /// Rule = FinallyClause ::= ((Keyword('finally')+CompoundStatement)+WS)
    /// Nodes = CompoundStatement
    /// </summary>
    public class CstFinallyClause : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.FinallyClause;
        public CstFinallyClause(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstCompoundStatement> CompoundStatement => new CstNodeFilter<CstCompoundStatement> (Children);
    }

    /// <summary>
    /// Rule = FloatLiteral ::= ((Float+(FloatSuffix)?)+WS)
    /// Nodes = 
    /// </summary>
    public class CstFloatLiteral : CstNodeLeaf, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.FloatLiteral;
        public CstFloatLiteral(ILocation location, string text) : base(location, text) { }
    }

    /// <summary>
    /// Rule = ForEachStatement ::= ((Keyword('foreach')+_RECOVER_+Symbol('(')+TypeExpr+Identifier+Keyword('in')+Expression+Symbol(')')+Statement)+WS)
    /// Nodes = (TypeExpr+Identifier+Expression+Statement)
    /// </summary>
    public class CstForEachStatement : CstNodeSequence, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.ForEachStatement;
        public CstForEachStatement(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstTypeExpr> TypeExpr => new CstNodeFilter<CstTypeExpr> (Children);
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
        public CstNodeFilter<CstStatement> Statement => new CstNodeFilter<CstStatement> (Children);
    }

    /// <summary>
    /// Rule = ForLoopInit ::= ((VarDecl)?+WS)
    /// Nodes = (VarDecl)?
    /// </summary>
    public class CstForLoopInit : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.ForLoopInit;
        public CstForLoopInit(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstVarDecl> VarDecl => new CstNodeFilter<CstVarDecl> (Children);
    }

    /// <summary>
    /// Rule = ForLoopInvariant ::= ((Expression)?+WS)
    /// Nodes = (Expression)?
    /// </summary>
    public class CstForLoopInvariant : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.ForLoopInvariant;
        public CstForLoopInvariant(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Rule = ForLoopVariant ::= ((((Expression+WS+((Comma+Expression+WS))*)+(Comma)?))?+WS)
    /// Nodes = (Expression)*
    /// </summary>
    public class CstForLoopVariant : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.ForLoopVariant;
        public CstForLoopVariant(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Rule = ForStatement ::= ((Keyword('for')+_RECOVER_+Symbol('(')+ForLoopInit+EOS+ForLoopInvariant+EOS+ForLoopVariant+Symbol(')')+Statement)+WS)
    /// Nodes = (ForLoopInit+ForLoopInvariant+ForLoopVariant+Statement)
    /// </summary>
    public class CstForStatement : CstNodeSequence, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.ForStatement;
        public CstForStatement(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstForLoopInit> ForLoopInit => new CstNodeFilter<CstForLoopInit> (Children);
        public CstNodeFilter<CstForLoopInvariant> ForLoopInvariant => new CstNodeFilter<CstForLoopInvariant> (Children);
        public CstNodeFilter<CstForLoopVariant> ForLoopVariant => new CstNodeFilter<CstForLoopVariant> (Children);
        public CstNodeFilter<CstStatement> Statement => new CstNodeFilter<CstStatement> (Children);
    }

    /// <summary>
    /// Rule = FunctionArg ::= (((FunctionArgKeyword)*+Expression)+WS)
    /// Nodes = ((FunctionArgKeyword)*+Expression)
    /// </summary>
    public class CstFunctionArg : CstNodeSequence, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.FunctionArg;
        public CstFunctionArg(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstFunctionArgKeyword> FunctionArgKeyword => new CstNodeFilter<CstFunctionArgKeyword> (Children);
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Rule = FunctionArgKeyword ::= ((Keyword('params')|Keyword('ref')|Keyword('out')|Keyword('in'))+WS)
    /// Nodes = 
    /// </summary>
    public class CstFunctionArgKeyword : CstNodeLeaf, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.FunctionArgKeyword;
        public CstFunctionArgKeyword(ILocation location, string text) : base(location, text) { }
    }

    /// <summary>
    /// Rule = FunctionArgs ::= (('('+WS+_UNKNOWN_+(((FunctionArg+WS+((Comma+FunctionArg+WS))*)+(Comma)?))?+WS+')'+WS)+WS)
    /// Nodes = (FunctionArg)*
    /// </summary>
    public class CstFunctionArgs : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.FunctionArgs;
        public CstFunctionArgs(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstFunctionArg> FunctionArg => new CstNodeFilter<CstFunctionArg> (Children);
    }

    /// <summary>
    /// Rule = FunctionBody ::= ((ExpressionBody|CompoundStatement|EOS)+WS)
    /// Nodes = (ExpressionBody|CompoundStatement)
    /// </summary>
    public class CstFunctionBody : CstNodeChoice, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.FunctionBody;
        public CstFunctionBody(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstExpressionBody> ExpressionBody => new CstNodeFilter<CstExpressionBody> (Children);
        public CstNodeFilter<CstCompoundStatement> CompoundStatement => new CstNodeFilter<CstCompoundStatement> (Children);
    }

    /// <summary>
    /// Rule = FunctionDeclStatement ::= (MethodDeclaration+WS)
    /// Nodes = MethodDeclaration
    /// </summary>
    public class CstFunctionDeclStatement : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.FunctionDeclStatement;
        public CstFunctionDeclStatement(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstMethodDeclaration> MethodDeclaration => new CstNodeFilter<CstMethodDeclaration> (Children);
    }

    /// <summary>
    /// Rule = FunctionName ::= (Identifier+WS)
    /// Nodes = Identifier
    /// </summary>
    public class CstFunctionName : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.FunctionName;
        public CstFunctionName(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
    }

    /// <summary>
    /// Rule = FunctionParameter ::= ((Identifier+TypeAnnotation)+WS)
    /// Nodes = (Identifier+TypeAnnotation)
    /// </summary>
    public class CstFunctionParameter : CstNodeSequence, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.FunctionParameter;
        public CstFunctionParameter(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
        public CstNodeFilter<CstTypeAnnotation> TypeAnnotation => new CstNodeFilter<CstTypeAnnotation> (Children);
    }

    /// <summary>
    /// Rule = FunctionParameterList ::= (('('+WS+_UNKNOWN_+(((FunctionParameter+WS+((Comma+FunctionParameter+WS))*)+(Comma)?))?+WS+')'+WS)+WS)
    /// Nodes = (FunctionParameter)*
    /// </summary>
    public class CstFunctionParameterList : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.FunctionParameterList;
        public CstFunctionParameterList(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstFunctionParameter> FunctionParameter => new CstNodeFilter<CstFunctionParameter> (Children);
    }

    /// <summary>
    /// Rule = HexLiteral ::= ((("0x"|"0X")+(HexDigit)++(IntegerSuffix)?)+WS)
    /// Nodes = 
    /// </summary>
    public class CstHexLiteral : CstNodeLeaf, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.HexLiteral;
        public CstHexLiteral(ILocation location, string text) : base(location, text) { }
    }

    /// <summary>
    /// Rule = Identifier ::= ((IdentifierFirstChar+(IdentifierChar)*)+WS)
    /// Nodes = 
    /// </summary>
    public class CstIdentifier : CstNodeLeaf, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Identifier;
        public CstIdentifier(ILocation location, string text) : base(location, text) { }
    }

    /// <summary>
    /// Rule = IfStatement ::= ((Keyword('if')+_RECOVER_+ParenthesizedExpression+Statement+(ElseClause)?)+WS)
    /// Nodes = (ParenthesizedExpression+Statement+(ElseClause)?)
    /// </summary>
    public class CstIfStatement : CstNodeSequence, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.IfStatement;
        public CstIfStatement(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstParenthesizedExpression> ParenthesizedExpression => new CstNodeFilter<CstParenthesizedExpression> (Children);
        public CstNodeFilter<CstStatement> Statement => new CstNodeFilter<CstStatement> (Children);
        public CstNodeFilter<CstElseClause> ElseClause => new CstNodeFilter<CstElseClause> (Children);
    }

    /// <summary>
    /// Rule = ImplementsList ::= (((Keyword('implements')+_RECOVER_+(((TypeExpr+WS+((Comma+TypeExpr+WS))*)+(Comma)?))?))?+WS)
    /// Nodes = (TypeExpr)*
    /// </summary>
    public class CstImplementsList : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.ImplementsList;
        public CstImplementsList(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstTypeExpr> TypeExpr => new CstNodeFilter<CstTypeExpr> (Children);
    }

    /// <summary>
    /// Rule = Indexer ::= (('['+WS+_UNKNOWN_+Expression+WS+']'+WS)+WS)
    /// Nodes = Expression
    /// </summary>
    public class CstIndexer : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Indexer;
        public CstIndexer(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Rule = InheritsList ::= (((Keyword('inherits')+_RECOVER_+(((TypeExpr+WS+((Comma+TypeExpr+WS))*)+(Comma)?))?))?+WS)
    /// Nodes = (TypeExpr)*
    /// </summary>
    public class CstInheritsList : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.InheritsList;
        public CstInheritsList(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstTypeExpr> TypeExpr => new CstNodeFilter<CstTypeExpr> (Children);
    }

    /// <summary>
    /// Rule = Initialization ::= (((Symbol('=')+_RECOVER_+InitializationValue))?+WS)
    /// Nodes = (InitializationValue)?
    /// </summary>
    public class CstInitialization : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Initialization;
        public CstInitialization(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstInitializationValue> InitializationValue => new CstNodeFilter<CstInitializationValue> (Children);
    }

    /// <summary>
    /// Rule = InitializationValue ::= ((ArrayInitializationValue|Expression)+WS)
    /// Nodes = (ArrayInitializationValue|Expression)
    /// </summary>
    public class CstInitializationValue : CstNodeChoice, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.InitializationValue;
        public CstInitializationValue(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstArrayInitializationValue> ArrayInitializationValue => new CstNodeFilter<CstArrayInitializationValue> (Children);
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Rule = Initializer ::= (('{'+WS+_UNKNOWN_+(((InitializerClause+WS+((Comma+InitializerClause+WS))*)+(Comma)?))?+WS+'}'+WS)+WS)
    /// Nodes = (InitializerClause)*
    /// </summary>
    public class CstInitializer : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Initializer;
        public CstInitializer(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstInitializerClause> InitializerClause => new CstNodeFilter<CstInitializerClause> (Children);
    }

    /// <summary>
    /// Rule = InitializerClause ::= (((Identifier+Symbol('=')+_RECOVER_+Expression)|Expression)+WS)
    /// Nodes = ((Identifier)?+Expression)
    /// </summary>
    public class CstInitializerClause : CstNodeSequence, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.InitializerClause;
        public CstInitializerClause(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Rule = InnerExpression ::= (((PrefixOperator)*+LeafExpression+(PostfixOperator)*)+WS)
    /// Nodes = ((PrefixOperator)*+LeafExpression+(PostfixOperator)*)
    /// </summary>
    public class CstInnerExpression : CstNodeSequence, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.InnerExpression;
        public CstInnerExpression(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstPrefixOperator> PrefixOperator => new CstNodeFilter<CstPrefixOperator> (Children);
        public CstNodeFilter<CstLeafExpression> LeafExpression => new CstNodeFilter<CstLeafExpression> (Children);
        public CstNodeFilter<CstPostfixOperator> PostfixOperator => new CstNodeFilter<CstPostfixOperator> (Children);
    }

    /// <summary>
    /// Rule = InnerStatement ::= ((EOS|CompoundStatement|IfStatement|WhileStatement|DoWhileStatement|ReturnStatement|BreakStatement|ContinueStatement|ForStatement|ForEachStatement|FunctionDeclStatement|VarDeclStatement|TryStatement|YieldStatement|SwitchStatement|ExpressionStatement)+WS)
    /// Nodes = (CompoundStatement|IfStatement|WhileStatement|DoWhileStatement|ReturnStatement|BreakStatement|ContinueStatement|ForStatement|ForEachStatement|FunctionDeclStatement|VarDeclStatement|TryStatement|YieldStatement|SwitchStatement|ExpressionStatement)
    /// </summary>
    public class CstInnerStatement : CstNodeChoice, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.InnerStatement;
        public CstInnerStatement(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstCompoundStatement> CompoundStatement => new CstNodeFilter<CstCompoundStatement> (Children);
        public CstNodeFilter<CstIfStatement> IfStatement => new CstNodeFilter<CstIfStatement> (Children);
        public CstNodeFilter<CstWhileStatement> WhileStatement => new CstNodeFilter<CstWhileStatement> (Children);
        public CstNodeFilter<CstDoWhileStatement> DoWhileStatement => new CstNodeFilter<CstDoWhileStatement> (Children);
        public CstNodeFilter<CstReturnStatement> ReturnStatement => new CstNodeFilter<CstReturnStatement> (Children);
        public CstNodeFilter<CstBreakStatement> BreakStatement => new CstNodeFilter<CstBreakStatement> (Children);
        public CstNodeFilter<CstContinueStatement> ContinueStatement => new CstNodeFilter<CstContinueStatement> (Children);
        public CstNodeFilter<CstForStatement> ForStatement => new CstNodeFilter<CstForStatement> (Children);
        public CstNodeFilter<CstForEachStatement> ForEachStatement => new CstNodeFilter<CstForEachStatement> (Children);
        public CstNodeFilter<CstFunctionDeclStatement> FunctionDeclStatement => new CstNodeFilter<CstFunctionDeclStatement> (Children);
        public CstNodeFilter<CstVarDeclStatement> VarDeclStatement => new CstNodeFilter<CstVarDeclStatement> (Children);
        public CstNodeFilter<CstTryStatement> TryStatement => new CstNodeFilter<CstTryStatement> (Children);
        public CstNodeFilter<CstYieldStatement> YieldStatement => new CstNodeFilter<CstYieldStatement> (Children);
        public CstNodeFilter<CstSwitchStatement> SwitchStatement => new CstNodeFilter<CstSwitchStatement> (Children);
        public CstNodeFilter<CstExpressionStatement> ExpressionStatement => new CstNodeFilter<CstExpressionStatement> (Children);
    }

    /// <summary>
    /// Rule = InnerTypeExpr ::= ((CompoundOrSimpleTypeExpr+(TypeArgList)?+ArrayRankSpecifiers)+WS)
    /// Nodes = (CompoundOrSimpleTypeExpr+(TypeArgList)?+ArrayRankSpecifiers)
    /// </summary>
    public class CstInnerTypeExpr : CstNodeSequence, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.InnerTypeExpr;
        public CstInnerTypeExpr(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstCompoundOrSimpleTypeExpr> CompoundOrSimpleTypeExpr => new CstNodeFilter<CstCompoundOrSimpleTypeExpr> (Children);
        public CstNodeFilter<CstTypeArgList> TypeArgList => new CstNodeFilter<CstTypeArgList> (Children);
        public CstNodeFilter<CstArrayRankSpecifiers> ArrayRankSpecifiers => new CstNodeFilter<CstArrayRankSpecifiers> (Children);
    }

    /// <summary>
    /// Rule = IntegerLiteral ::= ((Digits+!([DFMdfm])+(IntegerSuffix)?)+WS)
    /// Nodes = 
    /// </summary>
    public class CstIntegerLiteral : CstNodeLeaf, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.IntegerLiteral;
        public CstIntegerLiteral(ILocation location, string text) : base(location, text) { }
    }

    /// <summary>
    /// Rule = IsOperation ::= ((Keyword('is')+_RECOVER_+TypeExpr+(Identifier)?)+WS)
    /// Nodes = (TypeExpr+(Identifier)?)
    /// </summary>
    public class CstIsOperation : CstNodeSequence, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.IsOperation;
        public CstIsOperation(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstTypeExpr> TypeExpr => new CstNodeFilter<CstTypeExpr> (Children);
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
    }

    /// <summary>
    /// Rule = LambdaBody ::= ((CompoundStatement|Expression)+WS)
    /// Nodes = (CompoundStatement|Expression)
    /// </summary>
    public class CstLambdaBody : CstNodeChoice, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.LambdaBody;
        public CstLambdaBody(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstCompoundStatement> CompoundStatement => new CstNodeFilter<CstCompoundStatement> (Children);
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Rule = LambdaExpr ::= ((LambdaParameters+Symbol('=>')+_RECOVER_+LambdaBody)+WS)
    /// Nodes = (LambdaParameters+LambdaBody)
    /// </summary>
    public class CstLambdaExpr : CstNodeSequence, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.LambdaExpr;
        public CstLambdaExpr(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstLambdaParameters> LambdaParameters => new CstNodeFilter<CstLambdaParameters> (Children);
        public CstNodeFilter<CstLambdaBody> LambdaBody => new CstNodeFilter<CstLambdaBody> (Children);
    }

    /// <summary>
    /// Rule = LambdaParameter ::= (Identifier+WS)
    /// Nodes = Identifier
    /// </summary>
    public class CstLambdaParameter : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.LambdaParameter;
        public CstLambdaParameter(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
    }

    /// <summary>
    /// Rule = LambdaParameters ::= ((LambdaParameter|('('+WS+_UNKNOWN_+(((LambdaParameter+WS+((Comma+LambdaParameter+WS))*)+(Comma)?))?+WS+')'+WS))+WS)
    /// Nodes = (LambdaParameter|(LambdaParameter)*)
    /// </summary>
    public class CstLambdaParameters : CstNodeChoice, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.LambdaParameters;
        public CstLambdaParameters(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstLambdaParameter> LambdaParameter => new CstNodeFilter<CstLambdaParameter> (Children);
    }

    /// <summary>
    /// Rule = LeafExpression ::= ((LambdaExpr|CastExpression|ParenthesizedExpression|ArrayExpression|ThrowExpression|Literal|TypeOf|NameOf|Default|NewOperation|StringInterpolation|Identifier)+WS)
    /// Nodes = (LambdaExpr|CastExpression|ParenthesizedExpression|ArrayExpression|ThrowExpression|Literal|TypeOf|NameOf|Default|NewOperation|StringInterpolation|Identifier)
    /// </summary>
    public class CstLeafExpression : CstNodeChoice, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.LeafExpression;
        public CstLeafExpression(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstLambdaExpr> LambdaExpr => new CstNodeFilter<CstLambdaExpr> (Children);
        public CstNodeFilter<CstCastExpression> CastExpression => new CstNodeFilter<CstCastExpression> (Children);
        public CstNodeFilter<CstParenthesizedExpression> ParenthesizedExpression => new CstNodeFilter<CstParenthesizedExpression> (Children);
        public CstNodeFilter<CstArrayExpression> ArrayExpression => new CstNodeFilter<CstArrayExpression> (Children);
        public CstNodeFilter<CstThrowExpression> ThrowExpression => new CstNodeFilter<CstThrowExpression> (Children);
        public CstNodeFilter<CstLiteral> Literal => new CstNodeFilter<CstLiteral> (Children);
        public CstNodeFilter<CstTypeOf> TypeOf => new CstNodeFilter<CstTypeOf> (Children);
        public CstNodeFilter<CstNameOf> NameOf => new CstNodeFilter<CstNameOf> (Children);
        public CstNodeFilter<CstDefault> Default => new CstNodeFilter<CstDefault> (Children);
        public CstNodeFilter<CstNewOperation> NewOperation => new CstNodeFilter<CstNewOperation> (Children);
        public CstNodeFilter<CstStringInterpolation> StringInterpolation => new CstNodeFilter<CstStringInterpolation> (Children);
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
    }

    /// <summary>
    /// Rule = Library ::= ((Keyword('library')+_RECOVER_+Identifier+'{'+WS+_RECOVER_+(MethodDeclaration)*+WS+'}'+WS)+WS)
    /// Nodes = (Identifier+(MethodDeclaration)*)
    /// </summary>
    public class CstLibrary : CstNodeSequence, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Library;
        public CstLibrary(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
        public CstNodeFilter<CstMethodDeclaration> MethodDeclaration => new CstNodeFilter<CstMethodDeclaration> (Children);
    }

    /// <summary>
    /// Rule = Literal ::= ((HexLiteral|BinaryLiteral|FloatLiteral|IntegerLiteral|StringLiteral|CharLiteral|BooleanLiteral|NullLiteral)+WS)
    /// Nodes = (HexLiteral|BinaryLiteral|FloatLiteral|IntegerLiteral|StringLiteral|CharLiteral|BooleanLiteral|NullLiteral)
    /// </summary>
    public class CstLiteral : CstNodeChoice, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Literal;
        public CstLiteral(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstHexLiteral> HexLiteral => new CstNodeFilter<CstHexLiteral> (Children);
        public CstNodeFilter<CstBinaryLiteral> BinaryLiteral => new CstNodeFilter<CstBinaryLiteral> (Children);
        public CstNodeFilter<CstFloatLiteral> FloatLiteral => new CstNodeFilter<CstFloatLiteral> (Children);
        public CstNodeFilter<CstIntegerLiteral> IntegerLiteral => new CstNodeFilter<CstIntegerLiteral> (Children);
        public CstNodeFilter<CstStringLiteral> StringLiteral => new CstNodeFilter<CstStringLiteral> (Children);
        public CstNodeFilter<CstCharLiteral> CharLiteral => new CstNodeFilter<CstCharLiteral> (Children);
        public CstNodeFilter<CstBooleanLiteral> BooleanLiteral => new CstNodeFilter<CstBooleanLiteral> (Children);
        public CstNodeFilter<CstNullLiteral> NullLiteral => new CstNodeFilter<CstNullLiteral> (Children);
    }

    /// <summary>
    /// Rule = MemberAccess ::= ((Symbol('.')+Identifier)+WS)
    /// Nodes = Identifier
    /// </summary>
    public class CstMemberAccess : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.MemberAccess;
        public CstMemberAccess(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
    }

    /// <summary>
    /// Rule = MethodDeclaration ::= ((Identifier+FunctionParameterList+_RECOVER_+TypeAnnotation+FunctionBody)+WS)
    /// Nodes = (Identifier+FunctionParameterList+TypeAnnotation+FunctionBody)
    /// </summary>
    public class CstMethodDeclaration : CstNodeSequence, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.MethodDeclaration;
        public CstMethodDeclaration(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
        public CstNodeFilter<CstFunctionParameterList> FunctionParameterList => new CstNodeFilter<CstFunctionParameterList> (Children);
        public CstNodeFilter<CstTypeAnnotation> TypeAnnotation => new CstNodeFilter<CstTypeAnnotation> (Children);
        public CstNodeFilter<CstFunctionBody> FunctionBody => new CstNodeFilter<CstFunctionBody> (Children);
    }

    /// <summary>
    /// Rule = NameOf ::= ((Keyword('nameof')+_RECOVER_+'('+WS+_UNKNOWN_+Expression+WS+')'+WS)+WS)
    /// Nodes = Expression
    /// </summary>
    public class CstNameOf : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.NameOf;
        public CstNameOf(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Rule = NewOperation ::= ((Keyword('new')+_RECOVER_+(TypeExpr)?+(FunctionArgs)?+(ArraySizeSpecifier)?+(Initializer)?)+WS)
    /// Nodes = ((TypeExpr)?+(FunctionArgs)?+(ArraySizeSpecifier)?+(Initializer)?)
    /// </summary>
    public class CstNewOperation : CstNodeSequence, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.NewOperation;
        public CstNewOperation(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstTypeExpr> TypeExpr => new CstNodeFilter<CstTypeExpr> (Children);
        public CstNodeFilter<CstFunctionArgs> FunctionArgs => new CstNodeFilter<CstFunctionArgs> (Children);
        public CstNodeFilter<CstArraySizeSpecifier> ArraySizeSpecifier => new CstNodeFilter<CstArraySizeSpecifier> (Children);
        public CstNodeFilter<CstInitializer> Initializer => new CstNodeFilter<CstInitializer> (Children);
    }

    /// <summary>
    /// Rule = NullLiteral ::= (Keyword('null')+WS)
    /// Nodes = 
    /// </summary>
    public class CstNullLiteral : CstNodeLeaf, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.NullLiteral;
        public CstNullLiteral(ILocation location, string text) : base(location, text) { }
    }

    /// <summary>
    /// Rule = Operator ::= (([\x21\x23-\x26\x2A+\x2D\x2F\x3A<-\x40^|~])++WS)
    /// Nodes = 
    /// </summary>
    public class CstOperator : CstNodeLeaf, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Operator;
        public CstOperator(ILocation location, string text) : base(location, text) { }
    }

    /// <summary>
    /// Rule = ParameterName ::= (Identifier+WS)
    /// Nodes = Identifier
    /// </summary>
    public class CstParameterName : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.ParameterName;
        public CstParameterName(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
    }

    /// <summary>
    /// Rule = ParenthesizedExpression ::= (('('+WS+_UNKNOWN_+(((Expression+WS+((Comma+Expression+WS))*)+(Comma)?))?+WS+')'+WS)+WS)
    /// Nodes = (Expression)*
    /// </summary>
    public class CstParenthesizedExpression : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.ParenthesizedExpression;
        public CstParenthesizedExpression(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Rule = ParenthesizedTokenGroup ::= (('('+WS+_UNKNOWN_+Token+WS+')'+WS)+WS)
    /// Nodes = ((TypeKeyword+TypeName)|(FieldName+TypeName+(TypeParametersToken)?)|(FunctionName+ParameterName+TypeName+(TypeParametersToken)?+((ParameterName+TypeName+(TypeParametersToken)?))*+((TypeName+(TypeParametersToken)?))?)|Separator|Delimiter|Operator|Identifier|HexLiteral|BinaryLiteral|FloatLiteral|IntegerLiteral|StringLiteral|CharLiteral|BooleanLiteral|NullLiteral|Unknown)
    /// </summary>
    public class CstParenthesizedTokenGroup : CstNodeChoice, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.ParenthesizedTokenGroup;
        public CstParenthesizedTokenGroup(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstTypeKeyword> TypeKeyword => new CstNodeFilter<CstTypeKeyword> (Children);
        public CstNodeFilter<CstTypeName> TypeName => new CstNodeFilter<CstTypeName> (Children);
        public CstNodeFilter<CstFieldName> FieldName => new CstNodeFilter<CstFieldName> (Children);
        public CstNodeFilter<CstTypeParametersToken> TypeParametersToken => new CstNodeFilter<CstTypeParametersToken> (Children);
        public CstNodeFilter<CstFunctionName> FunctionName => new CstNodeFilter<CstFunctionName> (Children);
        public CstNodeFilter<CstParameterName> ParameterName => new CstNodeFilter<CstParameterName> (Children);
        public CstNodeFilter<CstSeparator> Separator => new CstNodeFilter<CstSeparator> (Children);
        public CstNodeFilter<CstDelimiter> Delimiter => new CstNodeFilter<CstDelimiter> (Children);
        public CstNodeFilter<CstOperator> Operator => new CstNodeFilter<CstOperator> (Children);
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
        public CstNodeFilter<CstHexLiteral> HexLiteral => new CstNodeFilter<CstHexLiteral> (Children);
        public CstNodeFilter<CstBinaryLiteral> BinaryLiteral => new CstNodeFilter<CstBinaryLiteral> (Children);
        public CstNodeFilter<CstFloatLiteral> FloatLiteral => new CstNodeFilter<CstFloatLiteral> (Children);
        public CstNodeFilter<CstIntegerLiteral> IntegerLiteral => new CstNodeFilter<CstIntegerLiteral> (Children);
        public CstNodeFilter<CstStringLiteral> StringLiteral => new CstNodeFilter<CstStringLiteral> (Children);
        public CstNodeFilter<CstCharLiteral> CharLiteral => new CstNodeFilter<CstCharLiteral> (Children);
        public CstNodeFilter<CstBooleanLiteral> BooleanLiteral => new CstNodeFilter<CstBooleanLiteral> (Children);
        public CstNodeFilter<CstNullLiteral> NullLiteral => new CstNodeFilter<CstNullLiteral> (Children);
        public CstNodeFilter<CstUnknown> Unknown => new CstNodeFilter<CstUnknown> (Children);
    }

    /// <summary>
    /// Rule = PostfixOperator ::= ((Symbol('++')|Symbol('--')|MemberAccess|ConditionalMemberAccess|FunctionArgs|Indexer|TernaryOperation|BinaryOperation|IsOperation|AsOperation)+WS)
    /// Nodes = (MemberAccess|ConditionalMemberAccess|FunctionArgs|Indexer|TernaryOperation|BinaryOperation|IsOperation|AsOperation)
    /// </summary>
    public class CstPostfixOperator : CstNodeChoice, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.PostfixOperator;
        public CstPostfixOperator(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstMemberAccess> MemberAccess => new CstNodeFilter<CstMemberAccess> (Children);
        public CstNodeFilter<CstConditionalMemberAccess> ConditionalMemberAccess => new CstNodeFilter<CstConditionalMemberAccess> (Children);
        public CstNodeFilter<CstFunctionArgs> FunctionArgs => new CstNodeFilter<CstFunctionArgs> (Children);
        public CstNodeFilter<CstIndexer> Indexer => new CstNodeFilter<CstIndexer> (Children);
        public CstNodeFilter<CstTernaryOperation> TernaryOperation => new CstNodeFilter<CstTernaryOperation> (Children);
        public CstNodeFilter<CstBinaryOperation> BinaryOperation => new CstNodeFilter<CstBinaryOperation> (Children);
        public CstNodeFilter<CstIsOperation> IsOperation => new CstNodeFilter<CstIsOperation> (Children);
        public CstNodeFilter<CstAsOperation> AsOperation => new CstNodeFilter<CstAsOperation> (Children);
    }

    /// <summary>
    /// Rule = PrefixOperator ::= ((Symbol('++')|Symbol('--')|Symbol('!')|Symbol('-')|Symbol('+')|Symbol('~'))+WS)
    /// Nodes = 
    /// </summary>
    public class CstPrefixOperator : CstNodeLeaf, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.PrefixOperator;
        public CstPrefixOperator(ILocation location, string text) : base(location, text) { }
    }

    /// <summary>
    /// Rule = QualifiedIdentifier ::= ((((Identifier+WS+((Symbol('.')+Identifier+WS))*)+(Symbol('.'))?))?+WS)
    /// Nodes = (Identifier)*
    /// </summary>
    public class CstQualifiedIdentifier : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.QualifiedIdentifier;
        public CstQualifiedIdentifier(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
    }

    /// <summary>
    /// Rule = ReturnStatement ::= ((Keyword('return')+_RECOVER_+(Expression)?+EOS)+WS)
    /// Nodes = (Expression)?
    /// </summary>
    public class CstReturnStatement : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.ReturnStatement;
        public CstReturnStatement(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Rule = Separator ::= (([\x2C\x2E\x3B]|TypeKeyword|StatementKeyword)+WS)
    /// Nodes = (TypeKeyword|StatementKeyword)
    /// </summary>
    public class CstSeparator : CstNodeChoice, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Separator;
        public CstSeparator(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstTypeKeyword> TypeKeyword => new CstNodeFilter<CstTypeKeyword> (Children);
        public CstNodeFilter<CstStatementKeyword> StatementKeyword => new CstNodeFilter<CstStatementKeyword> (Children);
    }

    /// <summary>
    /// Rule = SimpleTypeExpr ::= (Identifier+WS)
    /// Nodes = Identifier
    /// </summary>
    public class CstSimpleTypeExpr : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.SimpleTypeExpr;
        public CstSimpleTypeExpr(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
    }

    /// <summary>
    /// Rule = Statement ::= (InnerStatement+WS)
    /// Nodes = InnerStatement
    /// </summary>
    public class CstStatement : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Statement;
        public CstStatement(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstInnerStatement> InnerStatement => new CstNodeFilter<CstInnerStatement> (Children);
    }

    /// <summary>
    /// Rule = StatementKeyword ::= ((Keyword('continue')|Keyword('foreach')|Keyword('finally')|Keyword('default')|Keyword('return')|Keyword('switch')|Keyword('break')|Keyword('throw')|Keyword('catch')|Keyword('using')|Keyword('case')|Keyword('for')|Keyword('try')|Keyword('if')|Keyword('do'))+WS)
    /// Nodes = 
    /// </summary>
    public class CstStatementKeyword : CstNodeLeaf, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.StatementKeyword;
        public CstStatementKeyword(ILocation location, string text) : base(location, text) { }
    }

    /// <summary>
    /// Rule = StringInterpolation ::= (('$'+_RECOVER_+'"'+(StringInterpolationContent)*+'"')+WS)
    /// Nodes = (StringInterpolationContent)*
    /// </summary>
    public class CstStringInterpolation : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.StringInterpolation;
        public CstStringInterpolation(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstStringInterpolationContent> StringInterpolationContent => new CstNodeFilter<CstStringInterpolationContent> (Children);
    }

    /// <summary>
    /// Rule = StringInterpolationContent ::= ((('{'+WS+_UNKNOWN_+Expression+WS+'}'+WS)|StringLiteralChar)+WS)
    /// Nodes = Expression
    /// </summary>
    public class CstStringInterpolationContent : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.StringInterpolationContent;
        public CstStringInterpolationContent(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Rule = StringLiteral ::= ((('@')?+'"'+(StringLiteralChar)*+'"')+WS)
    /// Nodes = 
    /// </summary>
    public class CstStringLiteral : CstNodeLeaf, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.StringLiteral;
        public CstStringLiteral(ILocation location, string text) : base(location, text) { }
    }

    /// <summary>
    /// Rule = SwitchStatement ::= ((Keyword('switch')+_RECOVER_+'{'+WS+_RECOVER_+(CaseClause)*+WS+'}'+WS)+WS)
    /// Nodes = (CaseClause)*
    /// </summary>
    public class CstSwitchStatement : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.SwitchStatement;
        public CstSwitchStatement(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstCaseClause> CaseClause => new CstNodeFilter<CstCaseClause> (Children);
    }

    /// <summary>
    /// Rule = TernaryOperation ::= ((Symbol('?')+_RECOVER_+Expression+Symbol(':')+Expression)+WS)
    /// Nodes = (Expression+Expression)
    /// </summary>
    public class CstTernaryOperation : CstNodeSequence, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.TernaryOperation;
        public CstTernaryOperation(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Rule = ThrowExpression ::= ((Keyword('throw')+_RECOVER_+Expression)+WS)
    /// Nodes = Expression
    /// </summary>
    public class CstThrowExpression : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.ThrowExpression;
        public CstThrowExpression(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Rule = TokenGroup ::= (((BracedTokenGroup|BracketedTokenGroup|ParenthesizedTokenGroup|Token))++WS)
    /// Nodes = ((BracedTokenGroup|BracketedTokenGroup|ParenthesizedTokenGroup))+
    /// </summary>
    public class CstTokenGroup : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.TokenGroup;
        public CstTokenGroup(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstBracedTokenGroup> BracedTokenGroup => new CstNodeFilter<CstBracedTokenGroup> (Children);
        public CstNodeFilter<CstBracketedTokenGroup> BracketedTokenGroup => new CstNodeFilter<CstBracketedTokenGroup> (Children);
        public CstNodeFilter<CstParenthesizedTokenGroup> ParenthesizedTokenGroup => new CstNodeFilter<CstParenthesizedTokenGroup> (Children);
    }

    /// <summary>
    /// Rule = TopLevelDeclaration ::= ((Library|Concept|Type)+WS)
    /// Nodes = (Library|Concept|Type)
    /// </summary>
    public class CstTopLevelDeclaration : CstNodeChoice, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.TopLevelDeclaration;
        public CstTopLevelDeclaration(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstLibrary> Library => new CstNodeFilter<CstLibrary> (Children);
        public CstNodeFilter<CstConcept> Concept => new CstNodeFilter<CstConcept> (Children);
        public CstNodeFilter<CstType> Type => new CstNodeFilter<CstType> (Children);
    }

    /// <summary>
    /// Rule = TryStatement ::= ((Keyword('try')+_RECOVER_+CompoundStatement+(CatchClause)?+(FinallyClause)?)+WS)
    /// Nodes = (CompoundStatement+(CatchClause)?+(FinallyClause)?)
    /// </summary>
    public class CstTryStatement : CstNodeSequence, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.TryStatement;
        public CstTryStatement(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstCompoundStatement> CompoundStatement => new CstNodeFilter<CstCompoundStatement> (Children);
        public CstNodeFilter<CstCatchClause> CatchClause => new CstNodeFilter<CstCatchClause> (Children);
        public CstNodeFilter<CstFinallyClause> FinallyClause => new CstNodeFilter<CstFinallyClause> (Children);
    }

    /// <summary>
    /// Rule = Type ::= ((Keyword('type')+_RECOVER_+Identifier+TypeParameterList+ImplementsList+'{'+WS+_RECOVER_+(FieldDeclaration)*+WS+'}'+WS)+WS)
    /// Nodes = (Identifier+TypeParameterList+ImplementsList+(FieldDeclaration)*)
    /// </summary>
    public class CstType : CstNodeSequence, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Type;
        public CstType(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
        public CstNodeFilter<CstTypeParameterList> TypeParameterList => new CstNodeFilter<CstTypeParameterList> (Children);
        public CstNodeFilter<CstImplementsList> ImplementsList => new CstNodeFilter<CstImplementsList> (Children);
        public CstNodeFilter<CstFieldDeclaration> FieldDeclaration => new CstNodeFilter<CstFieldDeclaration> (Children);
    }

    /// <summary>
    /// Rule = TypeAnnotation ::= ((Symbol(':')+_RECOVER_+TypeExpr)+WS)
    /// Nodes = TypeExpr
    /// </summary>
    public class CstTypeAnnotation : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.TypeAnnotation;
        public CstTypeAnnotation(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstTypeExpr> TypeExpr => new CstNodeFilter<CstTypeExpr> (Children);
    }

    /// <summary>
    /// Rule = TypeArgList ::= (('<'+WS+_UNKNOWN_+(((TypeExpr+WS+((Comma+TypeExpr+WS))*)+(Comma)?))?+WS+'>'+WS)+WS)
    /// Nodes = (TypeExpr)*
    /// </summary>
    public class CstTypeArgList : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.TypeArgList;
        public CstTypeArgList(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstTypeExpr> TypeExpr => new CstNodeFilter<CstTypeExpr> (Children);
    }

    /// <summary>
    /// Rule = TypeExpr ::= (InnerTypeExpr+WS)
    /// Nodes = InnerTypeExpr
    /// </summary>
    public class CstTypeExpr : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.TypeExpr;
        public CstTypeExpr(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstInnerTypeExpr> InnerTypeExpr => new CstNodeFilter<CstInnerTypeExpr> (Children);
    }

    /// <summary>
    /// Rule = TypeKeyword ::= ((Keyword('concept')|Keyword('library')|Keyword('type'))+WS)
    /// Nodes = 
    /// </summary>
    public class CstTypeKeyword : CstNodeLeaf, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.TypeKeyword;
        public CstTypeKeyword(ILocation location, string text) : base(location, text) { }
    }

    /// <summary>
    /// Rule = TypeName ::= (Identifier+WS)
    /// Nodes = Identifier
    /// </summary>
    public class CstTypeName : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.TypeName;
        public CstTypeName(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
    }

    /// <summary>
    /// Rule = TypeOf ::= ((Keyword('typeof')+_RECOVER_+'('+WS+_UNKNOWN_+TypeExpr+WS+')'+WS)+WS)
    /// Nodes = TypeExpr
    /// </summary>
    public class CstTypeOf : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.TypeOf;
        public CstTypeOf(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstTypeExpr> TypeExpr => new CstNodeFilter<CstTypeExpr> (Children);
    }

    /// <summary>
    /// Rule = TypeParameter ::= (Identifier+WS)
    /// Nodes = Identifier
    /// </summary>
    public class CstTypeParameter : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.TypeParameter;
        public CstTypeParameter(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
    }

    /// <summary>
    /// Rule = TypeParameterList ::= ((('<'+WS+_UNKNOWN_+(((TypeParameter+WS+((Comma+TypeParameter+WS))*)+(Comma)?))?+WS+'>'+WS))?+WS)
    /// Nodes = (TypeParameter)*
    /// </summary>
    public class CstTypeParameterList : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.TypeParameterList;
        public CstTypeParameterList(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstTypeParameter> TypeParameter => new CstNodeFilter<CstTypeParameter> (Children);
    }

    /// <summary>
    /// Rule = TypeParametersToken ::= (('<'+CommentOrSpaces+TypeParameterToken+CommentOrSpaces+((','+CommentOrSpaces+TypeParameterToken))*+'>'+CommentOrSpaces)+WS)
    /// Nodes = (TypeParameterToken)+
    /// </summary>
    public class CstTypeParametersToken : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.TypeParametersToken;
        public CstTypeParametersToken(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstTypeParameterToken> TypeParameterToken => new CstNodeFilter<CstTypeParameterToken> (Children);
    }

    /// <summary>
    /// Rule = TypeParameterToken ::= ((Identifier+CommentOrSpaces+TypeAnnotationToken)+WS)
    /// Nodes = Identifier
    /// </summary>
    public class CstTypeParameterToken : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.TypeParameterToken;
        public CstTypeParameterToken(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
    }

    /// <summary>
    /// Rule = TypeVar ::= (('$'+Identifier)+WS)
    /// Nodes = Identifier
    /// </summary>
    public class CstTypeVar : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.TypeVar;
        public CstTypeVar(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
    }

    /// <summary>
    /// Rule = Unknown ::= (AnyChar+WS)
    /// Nodes = 
    /// </summary>
    public class CstUnknown : CstNodeLeaf, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Unknown;
        public CstUnknown(ILocation location, string text) : base(location, text) { }
    }

    /// <summary>
    /// Rule = VarDecl ::= ((TypeExpr+(VarWithInitialization+WS+((Comma+VarWithInitialization+WS))*)+(Comma)?)+WS)
    /// Nodes = (TypeExpr+(VarWithInitialization)+)
    /// </summary>
    public class CstVarDecl : CstNodeSequence, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.VarDecl;
        public CstVarDecl(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstTypeExpr> TypeExpr => new CstNodeFilter<CstTypeExpr> (Children);
        public CstNodeFilter<CstVarWithInitialization> VarWithInitialization => new CstNodeFilter<CstVarWithInitialization> (Children);
    }

    /// <summary>
    /// Rule = VarDeclStatement ::= ((VarDecl+EOS)+WS)
    /// Nodes = VarDecl
    /// </summary>
    public class CstVarDeclStatement : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.VarDeclStatement;
        public CstVarDeclStatement(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstVarDecl> VarDecl => new CstNodeFilter<CstVarDecl> (Children);
    }

    /// <summary>
    /// Rule = VarWithInitialization ::= ((Identifier+Initialization)+WS)
    /// Nodes = (Identifier+Initialization)
    /// </summary>
    public class CstVarWithInitialization : CstNodeSequence, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.VarWithInitialization;
        public CstVarWithInitialization(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
        public CstNodeFilter<CstInitialization> Initialization => new CstNodeFilter<CstInitialization> (Children);
    }

    /// <summary>
    /// Rule = WhileStatement ::= ((Keyword('while')+_RECOVER_+ParenthesizedExpression+Statement)+WS)
    /// Nodes = (ParenthesizedExpression+Statement)
    /// </summary>
    public class CstWhileStatement : CstNodeSequence, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.WhileStatement;
        public CstWhileStatement(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstParenthesizedExpression> ParenthesizedExpression => new CstNodeFilter<CstParenthesizedExpression> (Children);
        public CstNodeFilter<CstStatement> Statement => new CstNodeFilter<CstStatement> (Children);
    }

    /// <summary>
    /// Rule = YieldBreak ::= ((Keyword('break')+_RECOVER_+EOS)+WS)
    /// Nodes = 
    /// </summary>
    public class CstYieldBreak : CstNodeLeaf, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.YieldBreak;
        public CstYieldBreak(ILocation location, string text) : base(location, text) { }
    }

    /// <summary>
    /// Rule = YieldReturn ::= ((Keyword('return')+_RECOVER_+Expression+EOS)+WS)
    /// Nodes = Expression
    /// </summary>
    public class CstYieldReturn : CstNode, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.YieldReturn;
        public CstYieldReturn(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Rule = YieldStatement ::= ((Keyword('yield')+_RECOVER_+(YieldReturn|YieldBreak))+WS)
    /// Nodes = (YieldReturn|YieldBreak)
    /// </summary>
    public class CstYieldStatement : CstNodeChoice, IPlatoCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.YieldStatement;
        public CstYieldStatement(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstYieldReturn> YieldReturn => new CstNodeFilter<CstYieldReturn> (Children);
        public CstNodeFilter<CstYieldBreak> YieldBreak => new CstNodeFilter<CstYieldBreak> (Children);
    }

}
