// DO NOT EDIT: Autogenerated file created on 2024-01-26 1:43:39 AM. 
using System;
using System.Linq;
using Ara3D.Parsing;

namespace Parakeet.Cst.CSharpGrammar
{
    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstAccessSpecifier : CstLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.AccessSpecifier;
        public CstAccessSpecifier(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = (Expression)*
    /// </summary>
    public class CstArrayInitializationValue : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.ArrayInitializationValue;
        public CstArrayInitializationValue(params CstNode[] children) : base(children) { }
        public CstFilter<CstExpression> Expression => new CstFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstArrayRankSpecifier : CstLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.ArrayRankSpecifier;
        public CstArrayRankSpecifier(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = (ArrayRankSpecifier)*
    /// </summary>
    public class CstArrayRankSpecifiers : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.ArrayRankSpecifiers;
        public CstArrayRankSpecifiers(params CstNode[] children) : base(children) { }
        public CstFilter<CstArrayRankSpecifier> ArrayRankSpecifier => new CstFilter<CstArrayRankSpecifier> (Children);
    }

    /// <summary>
    /// Nodes = Expression
    /// </summary>
    public class CstArraySizeSpecifier : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.ArraySizeSpecifier;
        public CstArraySizeSpecifier(params CstNode[] children) : base(children) { }
        public CstFilter<CstExpression> Expression => new CstFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Nodes = (TypeExpr+(Identifier)?)
    /// </summary>
    public class CstAsOperation : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.AsOperation;
        public CstAsOperation(params CstNode[] children) : base(children) { }
        public CstFilter<CstTypeExpr> TypeExpr => new CstFilter<CstTypeExpr> (Children);
        public CstFilter<CstIdentifier> Identifier => new CstFilter<CstIdentifier> (Children);
    }

    /// <summary>
    /// Nodes = (Identifier+(FunctionArgs)?)
    /// </summary>
    public class CstAttribute : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.Attribute;
        public CstAttribute(params CstNode[] children) : base(children) { }
        public CstFilter<CstIdentifier> Identifier => new CstFilter<CstIdentifier> (Children);
        public CstFilter<CstFunctionArgs> FunctionArgs => new CstFilter<CstFunctionArgs> (Children);
    }

    /// <summary>
    /// Nodes = (Attribute)*
    /// </summary>
    public class CstAttributeGroup : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.AttributeGroup;
        public CstAttributeGroup(params CstNode[] children) : base(children) { }
        public CstFilter<CstAttribute> Attribute => new CstFilter<CstAttribute> (Children);
    }

    /// <summary>
    /// Nodes = (AttributeGroup)*
    /// </summary>
    public class CstAttributeList : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.AttributeList;
        public CstAttributeList(params CstNode[] children) : base(children) { }
        public CstFilter<CstAttributeGroup> AttributeGroup => new CstFilter<CstAttributeGroup> (Children);
    }

    /// <summary>
    /// Nodes = ParenthesizedExpression
    /// </summary>
    public class CstBaseCall : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.BaseCall;
        public CstBaseCall(params CstNode[] children) : base(children) { }
        public CstFilter<CstParenthesizedExpression> ParenthesizedExpression => new CstFilter<CstParenthesizedExpression> (Children);
    }

    /// <summary>
    /// Nodes = (TypeExpr)*
    /// </summary>
    public class CstBaseClassList : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.BaseClassList;
        public CstBaseClassList(params CstNode[] children) : base(children) { }
        public CstFilter<CstTypeExpr> TypeExpr => new CstFilter<CstTypeExpr> (Children);
    }

    /// <summary>
    /// Nodes = ((BaseCall|ThisCall))?
    /// </summary>
    public class CstBaseOrThisCall : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.BaseOrThisCall;
        public CstBaseOrThisCall(params CstNode[] children) : base(children) { }
        public CstFilter<CstBaseCall> BaseCall => new CstFilter<CstBaseCall> (Children);
        public CstFilter<CstThisCall> ThisCall => new CstFilter<CstThisCall> (Children);
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstBinaryLiteral : CstLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.BinaryLiteral;
        public CstBinaryLiteral(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = (BinaryOperator+Expression)
    /// </summary>
    public class CstBinaryOperation : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.BinaryOperation;
        public CstBinaryOperation(params CstNode[] children) : base(children) { }
        public CstFilter<CstBinaryOperator> BinaryOperator => new CstFilter<CstBinaryOperator> (Children);
        public CstFilter<CstExpression> Expression => new CstFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstBinaryOperator : CstLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.BinaryOperator;
        public CstBinaryOperator(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstBooleanLiteral : CstLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.BooleanLiteral;
        public CstBooleanLiteral(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = (Element)*
    /// </summary>
    public class CstBracedStructure : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.BracedStructure;
        public CstBracedStructure(params CstNode[] children) : base(children) { }
        public CstFilter<CstElement> Element => new CstFilter<CstElement> (Children);
    }

    /// <summary>
    /// Nodes = (Element)*
    /// </summary>
    public class CstBracketedStructure : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.BracketedStructure;
        public CstBracketedStructure(params CstNode[] children) : base(children) { }
        public CstFilter<CstElement> Element => new CstFilter<CstElement> (Children);
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstBreakStatement : CstLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.BreakStatement;
        public CstBreakStatement(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = (Expression+Statement)
    /// </summary>
    public class CstCaseClause : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.CaseClause;
        public CstCaseClause(params CstNode[] children) : base(children) { }
        public CstFilter<CstExpression> Expression => new CstFilter<CstExpression> (Children);
        public CstFilter<CstStatement> Statement => new CstFilter<CstStatement> (Children);
    }

    /// <summary>
    /// Nodes = (TypeExpr+Expression)
    /// </summary>
    public class CstCastExpression : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.CastExpression;
        public CstCastExpression(params CstNode[] children) : base(children) { }
        public CstFilter<CstTypeExpr> TypeExpr => new CstFilter<CstTypeExpr> (Children);
        public CstFilter<CstExpression> Expression => new CstFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Nodes = (VarDecl+CompoundStatement)
    /// </summary>
    public class CstCatchClause : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.CatchClause;
        public CstCatchClause(params CstNode[] children) : base(children) { }
        public CstFilter<CstVarDecl> VarDecl => new CstFilter<CstVarDecl> (Children);
        public CstFilter<CstCompoundStatement> CompoundStatement => new CstFilter<CstCompoundStatement> (Children);
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstCharLiteral : CstLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.CharLiteral;
        public CstCharLiteral(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = (CompoundTypeExpr|SimpleTypExpr)
    /// </summary>
    public class CstCompoundOrSimpleTypeExpr : CstChoice
    {
        public static Rule Rule = CstNodeFactory.Grammar.CompoundOrSimpleTypeExpr;
        public CstCompoundOrSimpleTypeExpr(params CstNode[] children) : base(children) { }
        public CstFilter<CstCompoundTypeExpr> CompoundTypeExpr => new CstFilter<CstCompoundTypeExpr> (Children);
        public CstFilter<CstSimpleTypExpr> SimpleTypExpr => new CstFilter<CstSimpleTypExpr> (Children);
    }

    /// <summary>
    /// Nodes = (Statement)*
    /// </summary>
    public class CstCompoundStatement : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.CompoundStatement;
        public CstCompoundStatement(params CstNode[] children) : base(children) { }
        public CstFilter<CstStatement> Statement => new CstFilter<CstStatement> (Children);
    }

    /// <summary>
    /// Nodes = (TypeExpr)*
    /// </summary>
    public class CstCompoundTypeExpr : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.CompoundTypeExpr;
        public CstCompoundTypeExpr(params CstNode[] children) : base(children) { }
        public CstFilter<CstTypeExpr> TypeExpr => new CstFilter<CstTypeExpr> (Children);
    }

    /// <summary>
    /// Nodes = Identifier
    /// </summary>
    public class CstConditionalMemberAccess : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.ConditionalMemberAccess;
        public CstConditionalMemberAccess(params CstNode[] children) : base(children) { }
        public CstFilter<CstIdentifier> Identifier => new CstFilter<CstIdentifier> (Children);
    }

    /// <summary>
    /// Nodes = TypeExpr
    /// </summary>
    public class CstConstraint : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.Constraint;
        public CstConstraint(params CstNode[] children) : base(children) { }
        public CstFilter<CstTypeExpr> TypeExpr => new CstFilter<CstTypeExpr> (Children);
    }

    /// <summary>
    /// Nodes = (Identifier+TypeExpr)
    /// </summary>
    public class CstConstraintClause : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.ConstraintClause;
        public CstConstraintClause(params CstNode[] children) : base(children) { }
        public CstFilter<CstIdentifier> Identifier => new CstFilter<CstIdentifier> (Children);
        public CstFilter<CstTypeExpr> TypeExpr => new CstFilter<CstTypeExpr> (Children);
    }

    /// <summary>
    /// Nodes = (ConstraintClause)*
    /// </summary>
    public class CstConstraintList : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.ConstraintList;
        public CstConstraintList(params CstNode[] children) : base(children) { }
        public CstFilter<CstConstraintClause> ConstraintClause => new CstFilter<CstConstraintClause> (Children);
    }

    /// <summary>
    /// Nodes = (Identifier+FunctionParameterList+BaseOrThisCall+FunctionBody)
    /// </summary>
    public class CstConstructorDeclaration : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.ConstructorDeclaration;
        public CstConstructorDeclaration(params CstNode[] children) : base(children) { }
        public CstFilter<CstIdentifier> Identifier => new CstFilter<CstIdentifier> (Children);
        public CstFilter<CstFunctionParameterList> FunctionParameterList => new CstFilter<CstFunctionParameterList> (Children);
        public CstFilter<CstBaseOrThisCall> BaseOrThisCall => new CstFilter<CstBaseOrThisCall> (Children);
        public CstFilter<CstFunctionBody> FunctionBody => new CstFilter<CstFunctionBody> (Children);
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstContinueStatement : CstLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.ContinueStatement;
        public CstContinueStatement(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = (TypeExpr+ImplicitOrExplicit+TypeExpr+FunctionBody)
    /// </summary>
    public class CstConverterDeclaration : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.ConverterDeclaration;
        public CstConverterDeclaration(params CstNode[] children) : base(children) { }
        public CstFilter<CstTypeExpr> TypeExpr => new CstFilter<CstTypeExpr> (Children);
        public CstFilter<CstImplicitOrExplicit> ImplicitOrExplicit => new CstFilter<CstImplicitOrExplicit> (Children);
        public CstFilter<CstFunctionBody> FunctionBody => new CstFilter<CstFunctionBody> (Children);
    }

    /// <summary>
    /// Nodes = (AttributeList+((Modifier|AccessSpecifier))*)
    /// </summary>
    public class CstDeclarationPreamble : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.DeclarationPreamble;
        public CstDeclarationPreamble(params CstNode[] children) : base(children) { }
        public CstFilter<CstAttributeList> AttributeList => new CstFilter<CstAttributeList> (Children);
        public CstFilter<CstModifier> Modifier => new CstFilter<CstModifier> (Children);
        public CstFilter<CstAccessSpecifier> AccessSpecifier => new CstFilter<CstAccessSpecifier> (Children);
    }

    /// <summary>
    /// Nodes = (TypeExpr)?
    /// </summary>
    public class CstDefault : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.Default;
        public CstDefault(params CstNode[] children) : base(children) { }
        public CstFilter<CstTypeExpr> TypeExpr => new CstFilter<CstTypeExpr> (Children);
    }

    /// <summary>
    /// Nodes = (Statement+ParenthesizedExpression)
    /// </summary>
    public class CstDoWhileStatement : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.DoWhileStatement;
        public CstDoWhileStatement(params CstNode[] children) : base(children) { }
        public CstFilter<CstStatement> Statement => new CstFilter<CstStatement> (Children);
        public CstFilter<CstParenthesizedExpression> ParenthesizedExpression => new CstFilter<CstParenthesizedExpression> (Children);
    }

    /// <summary>
    /// Nodes = (Structure|TokenGroup)
    /// </summary>
    public class CstElement : CstChoice
    {
        public static Rule Rule = CstNodeFactory.Grammar.Element;
        public CstElement(params CstNode[] children) : base(children) { }
        public CstFilter<CstStructure> Structure => new CstFilter<CstStructure> (Children);
        public CstFilter<CstTokenGroup> TokenGroup => new CstFilter<CstTokenGroup> (Children);
    }

    /// <summary>
    /// Nodes = Statement
    /// </summary>
    public class CstElseClause : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.ElseClause;
        public CstElseClause(params CstNode[] children) : base(children) { }
        public CstFilter<CstStatement> Statement => new CstFilter<CstStatement> (Children);
    }

    /// <summary>
    /// Nodes = ((PrefixOperator)*+LeafExpression+(PostfixOperator)*)
    /// </summary>
    public class CstExpression : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.Expression;
        public CstExpression(params CstNode[] children) : base(children) { }
        public CstFilter<CstPrefixOperator> PrefixOperator => new CstFilter<CstPrefixOperator> (Children);
        public CstFilter<CstLeafExpression> LeafExpression => new CstFilter<CstLeafExpression> (Children);
        public CstFilter<CstPostfixOperator> PostfixOperator => new CstFilter<CstPostfixOperator> (Children);
    }

    /// <summary>
    /// Nodes = (Expression|CompoundStatement)
    /// </summary>
    public class CstExpressionBody : CstChoice
    {
        public static Rule Rule = CstNodeFactory.Grammar.ExpressionBody;
        public CstExpressionBody(params CstNode[] children) : base(children) { }
        public CstFilter<CstExpression> Expression => new CstFilter<CstExpression> (Children);
        public CstFilter<CstCompoundStatement> CompoundStatement => new CstFilter<CstCompoundStatement> (Children);
    }

    /// <summary>
    /// Nodes = Expression
    /// </summary>
    public class CstExpressionStatement : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.ExpressionStatement;
        public CstExpressionStatement(params CstNode[] children) : base(children) { }
        public CstFilter<CstExpression> Expression => new CstFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Nodes = VarDeclStatement
    /// </summary>
    public class CstFieldDeclaration : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.FieldDeclaration;
        public CstFieldDeclaration(params CstNode[] children) : base(children) { }
        public CstFilter<CstVarDeclStatement> VarDeclStatement => new CstFilter<CstVarDeclStatement> (Children);
    }

    /// <summary>
    /// Nodes = (((UsingDirective)*+(NamespaceDeclaration)?))*
    /// </summary>
    public class CstFile : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.File;
        public CstFile(params CstNode[] children) : base(children) { }
        public CstFilter<CstUsingDirective> UsingDirective => new CstFilter<CstUsingDirective> (Children);
        public CstFilter<CstNamespaceDeclaration> NamespaceDeclaration => new CstFilter<CstNamespaceDeclaration> (Children);
    }

    /// <summary>
    /// Nodes = (Element)*
    /// </summary>
    public class CstFileStructure : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.FileStructure;
        public CstFileStructure(params CstNode[] children) : base(children) { }
        public CstFilter<CstElement> Element => new CstFilter<CstElement> (Children);
    }

    /// <summary>
    /// Nodes = CompoundStatement
    /// </summary>
    public class CstFinallyClause : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.FinallyClause;
        public CstFinallyClause(params CstNode[] children) : base(children) { }
        public CstFilter<CstCompoundStatement> CompoundStatement => new CstFilter<CstCompoundStatement> (Children);
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstFloatLiteral : CstLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.FloatLiteral;
        public CstFloatLiteral(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = (TypeExpr+Identifier+Expression+Statement)
    /// </summary>
    public class CstForEachStatement : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.ForEachStatement;
        public CstForEachStatement(params CstNode[] children) : base(children) { }
        public CstFilter<CstTypeExpr> TypeExpr => new CstFilter<CstTypeExpr> (Children);
        public CstFilter<CstIdentifier> Identifier => new CstFilter<CstIdentifier> (Children);
        public CstFilter<CstExpression> Expression => new CstFilter<CstExpression> (Children);
        public CstFilter<CstStatement> Statement => new CstFilter<CstStatement> (Children);
    }

    /// <summary>
    /// Nodes = (VarDecl)?
    /// </summary>
    public class CstForLoopInit : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.ForLoopInit;
        public CstForLoopInit(params CstNode[] children) : base(children) { }
        public CstFilter<CstVarDecl> VarDecl => new CstFilter<CstVarDecl> (Children);
    }

    /// <summary>
    /// Nodes = (Expression)?
    /// </summary>
    public class CstForLoopInvariant : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.ForLoopInvariant;
        public CstForLoopInvariant(params CstNode[] children) : base(children) { }
        public CstFilter<CstExpression> Expression => new CstFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Nodes = (Expression)*
    /// </summary>
    public class CstForLoopVariant : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.ForLoopVariant;
        public CstForLoopVariant(params CstNode[] children) : base(children) { }
        public CstFilter<CstExpression> Expression => new CstFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Nodes = (ForLoopInit+ForLoopInvariant+ForLoopVariant+Statement)
    /// </summary>
    public class CstForStatement : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.ForStatement;
        public CstForStatement(params CstNode[] children) : base(children) { }
        public CstFilter<CstForLoopInit> ForLoopInit => new CstFilter<CstForLoopInit> (Children);
        public CstFilter<CstForLoopInvariant> ForLoopInvariant => new CstFilter<CstForLoopInvariant> (Children);
        public CstFilter<CstForLoopVariant> ForLoopVariant => new CstFilter<CstForLoopVariant> (Children);
        public CstFilter<CstStatement> Statement => new CstFilter<CstStatement> (Children);
    }

    /// <summary>
    /// Nodes = ((FunctionArgKeyword)*+Expression)
    /// </summary>
    public class CstFunctionArg : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.FunctionArg;
        public CstFunctionArg(params CstNode[] children) : base(children) { }
        public CstFilter<CstFunctionArgKeyword> FunctionArgKeyword => new CstFilter<CstFunctionArgKeyword> (Children);
        public CstFilter<CstExpression> Expression => new CstFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstFunctionArgKeyword : CstLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.FunctionArgKeyword;
        public CstFunctionArgKeyword(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = (FunctionArg)*
    /// </summary>
    public class CstFunctionArgs : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.FunctionArgs;
        public CstFunctionArgs(params CstNode[] children) : base(children) { }
        public CstFilter<CstFunctionArg> FunctionArg => new CstFilter<CstFunctionArg> (Children);
    }

    /// <summary>
    /// Nodes = (ExpressionBody|CompoundStatement)
    /// </summary>
    public class CstFunctionBody : CstChoice
    {
        public static Rule Rule = CstNodeFactory.Grammar.FunctionBody;
        public CstFunctionBody(params CstNode[] children) : base(children) { }
        public CstFilter<CstExpressionBody> ExpressionBody => new CstFilter<CstExpressionBody> (Children);
        public CstFilter<CstCompoundStatement> CompoundStatement => new CstFilter<CstCompoundStatement> (Children);
    }

    /// <summary>
    /// Nodes = MethodDeclaration
    /// </summary>
    public class CstFunctionDeclStatement : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.FunctionDeclStatement;
        public CstFunctionDeclStatement(params CstNode[] children) : base(children) { }
        public CstFilter<CstMethodDeclaration> MethodDeclaration => new CstFilter<CstMethodDeclaration> (Children);
    }

    /// <summary>
    /// Nodes = (AttributeList+FunctionParameterKeywords+TypeExpr+Identifier+FunctionParameterDefaultValue)
    /// </summary>
    public class CstFunctionParameter : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.FunctionParameter;
        public CstFunctionParameter(params CstNode[] children) : base(children) { }
        public CstFilter<CstAttributeList> AttributeList => new CstFilter<CstAttributeList> (Children);
        public CstFilter<CstFunctionParameterKeywords> FunctionParameterKeywords => new CstFilter<CstFunctionParameterKeywords> (Children);
        public CstFilter<CstTypeExpr> TypeExpr => new CstFilter<CstTypeExpr> (Children);
        public CstFilter<CstIdentifier> Identifier => new CstFilter<CstIdentifier> (Children);
        public CstFilter<CstFunctionParameterDefaultValue> FunctionParameterDefaultValue => new CstFilter<CstFunctionParameterDefaultValue> (Children);
    }

    /// <summary>
    /// Nodes = (Expression)?
    /// </summary>
    public class CstFunctionParameterDefaultValue : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.FunctionParameterDefaultValue;
        public CstFunctionParameterDefaultValue(params CstNode[] children) : base(children) { }
        public CstFilter<CstExpression> Expression => new CstFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstFunctionParameterKeywords : CstLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.FunctionParameterKeywords;
        public CstFunctionParameterKeywords(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = (FunctionParameter)*
    /// </summary>
    public class CstFunctionParameterList : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.FunctionParameterList;
        public CstFunctionParameterList(params CstNode[] children) : base(children) { }
        public CstFilter<CstFunctionParameter> FunctionParameter => new CstFilter<CstFunctionParameter> (Children);
    }

    /// <summary>
    /// Nodes = FunctionBody
    /// </summary>
    public class CstGetter : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.Getter;
        public CstGetter(params CstNode[] children) : base(children) { }
        public CstFilter<CstFunctionBody> FunctionBody => new CstFilter<CstFunctionBody> (Children);
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstHexLiteral : CstLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.HexLiteral;
        public CstHexLiteral(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstIdentifier : CstLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.Identifier;
        public CstIdentifier(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = (ParenthesizedExpression+Statement+(ElseClause)?)
    /// </summary>
    public class CstIfStatement : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.IfStatement;
        public CstIfStatement(params CstNode[] children) : base(children) { }
        public CstFilter<CstParenthesizedExpression> ParenthesizedExpression => new CstFilter<CstParenthesizedExpression> (Children);
        public CstFilter<CstStatement> Statement => new CstFilter<CstStatement> (Children);
        public CstFilter<CstElseClause> ElseClause => new CstFilter<CstElseClause> (Children);
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstImplicitOrExplicit : CstLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.ImplicitOrExplicit;
        public CstImplicitOrExplicit(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = Expression
    /// </summary>
    public class CstIndexer : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.Indexer;
        public CstIndexer(params CstNode[] children) : base(children) { }
        public CstFilter<CstExpression> Expression => new CstFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Nodes = (TypeExpr+FunctionParameter+PropertyBody)
    /// </summary>
    public class CstIndexerDeclaration : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.IndexerDeclaration;
        public CstIndexerDeclaration(params CstNode[] children) : base(children) { }
        public CstFilter<CstTypeExpr> TypeExpr => new CstFilter<CstTypeExpr> (Children);
        public CstFilter<CstFunctionParameter> FunctionParameter => new CstFilter<CstFunctionParameter> (Children);
        public CstFilter<CstPropertyBody> PropertyBody => new CstFilter<CstPropertyBody> (Children);
    }

    /// <summary>
    /// Nodes = (InitializationValue)?
    /// </summary>
    public class CstInitialization : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.Initialization;
        public CstInitialization(params CstNode[] children) : base(children) { }
        public CstFilter<CstInitializationValue> InitializationValue => new CstFilter<CstInitializationValue> (Children);
    }

    /// <summary>
    /// Nodes = (ArrayInitializationValue|Expression)
    /// </summary>
    public class CstInitializationValue : CstChoice
    {
        public static Rule Rule = CstNodeFactory.Grammar.InitializationValue;
        public CstInitializationValue(params CstNode[] children) : base(children) { }
        public CstFilter<CstArrayInitializationValue> ArrayInitializationValue => new CstFilter<CstArrayInitializationValue> (Children);
        public CstFilter<CstExpression> Expression => new CstFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Nodes = (InitializerClause)*
    /// </summary>
    public class CstInitializer : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.Initializer;
        public CstInitializer(params CstNode[] children) : base(children) { }
        public CstFilter<CstInitializerClause> InitializerClause => new CstFilter<CstInitializerClause> (Children);
    }

    /// <summary>
    /// Nodes = ((Identifier)?+Expression)
    /// </summary>
    public class CstInitializerClause : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.InitializerClause;
        public CstInitializerClause(params CstNode[] children) : base(children) { }
        public CstFilter<CstIdentifier> Identifier => new CstFilter<CstIdentifier> (Children);
        public CstFilter<CstExpression> Expression => new CstFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Nodes = FunctionBody
    /// </summary>
    public class CstInitter : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.Initter;
        public CstInitter(params CstNode[] children) : base(children) { }
        public CstFilter<CstFunctionBody> FunctionBody => new CstFilter<CstFunctionBody> (Children);
    }

    /// <summary>
    /// Nodes = (CompoundOrSimpleTypeExpr+(TypeArgList)?+ArrayRankSpecifiers)
    /// </summary>
    public class CstInnerTypeExpr : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.InnerTypeExpr;
        public CstInnerTypeExpr(params CstNode[] children) : base(children) { }
        public CstFilter<CstCompoundOrSimpleTypeExpr> CompoundOrSimpleTypeExpr => new CstFilter<CstCompoundOrSimpleTypeExpr> (Children);
        public CstFilter<CstTypeArgList> TypeArgList => new CstFilter<CstTypeArgList> (Children);
        public CstFilter<CstArrayRankSpecifiers> ArrayRankSpecifiers => new CstFilter<CstArrayRankSpecifiers> (Children);
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstIntegerLiteral : CstLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.IntegerLiteral;
        public CstIntegerLiteral(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = (TypeExpr+(Identifier)?)
    /// </summary>
    public class CstIsOperation : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.IsOperation;
        public CstIsOperation(params CstNode[] children) : base(children) { }
        public CstFilter<CstTypeExpr> TypeExpr => new CstFilter<CstTypeExpr> (Children);
        public CstFilter<CstIdentifier> Identifier => new CstFilter<CstIdentifier> (Children);
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstKind : CstLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.Kind;
        public CstKind(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = (CompoundStatement|Expression)
    /// </summary>
    public class CstLambdaBody : CstChoice
    {
        public static Rule Rule = CstNodeFactory.Grammar.LambdaBody;
        public CstLambdaBody(params CstNode[] children) : base(children) { }
        public CstFilter<CstCompoundStatement> CompoundStatement => new CstFilter<CstCompoundStatement> (Children);
        public CstFilter<CstExpression> Expression => new CstFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Nodes = (LambdaParameters+LambdaBody)
    /// </summary>
    public class CstLambdaExpr : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.LambdaExpr;
        public CstLambdaExpr(params CstNode[] children) : base(children) { }
        public CstFilter<CstLambdaParameters> LambdaParameters => new CstFilter<CstLambdaParameters> (Children);
        public CstFilter<CstLambdaBody> LambdaBody => new CstFilter<CstLambdaBody> (Children);
    }

    /// <summary>
    /// Nodes = ((TypeExpr)?+Identifier)
    /// </summary>
    public class CstLambdaParameter : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.LambdaParameter;
        public CstLambdaParameter(params CstNode[] children) : base(children) { }
        public CstFilter<CstTypeExpr> TypeExpr => new CstFilter<CstTypeExpr> (Children);
        public CstFilter<CstIdentifier> Identifier => new CstFilter<CstIdentifier> (Children);
    }

    /// <summary>
    /// Nodes = (LambdaParameter|(LambdaParameter)*)
    /// </summary>
    public class CstLambdaParameters : CstChoice
    {
        public static Rule Rule = CstNodeFactory.Grammar.LambdaParameters;
        public CstLambdaParameters(params CstNode[] children) : base(children) { }
        public CstFilter<CstLambdaParameter> LambdaParameter => new CstFilter<CstLambdaParameter> (Children);
    }

    /// <summary>
    /// Nodes = (LambdaExpr|CastExpression|ParenthesizedExpression|ThrowExpression|Literal|TypeOf|NameOf|Default|NewOperation|StringInterpolation|Identifier)
    /// </summary>
    public class CstLeafExpression : CstChoice
    {
        public static Rule Rule = CstNodeFactory.Grammar.LeafExpression;
        public CstLeafExpression(params CstNode[] children) : base(children) { }
        public CstFilter<CstLambdaExpr> LambdaExpr => new CstFilter<CstLambdaExpr> (Children);
        public CstFilter<CstCastExpression> CastExpression => new CstFilter<CstCastExpression> (Children);
        public CstFilter<CstParenthesizedExpression> ParenthesizedExpression => new CstFilter<CstParenthesizedExpression> (Children);
        public CstFilter<CstThrowExpression> ThrowExpression => new CstFilter<CstThrowExpression> (Children);
        public CstFilter<CstLiteral> Literal => new CstFilter<CstLiteral> (Children);
        public CstFilter<CstTypeOf> TypeOf => new CstFilter<CstTypeOf> (Children);
        public CstFilter<CstNameOf> NameOf => new CstFilter<CstNameOf> (Children);
        public CstFilter<CstDefault> Default => new CstFilter<CstDefault> (Children);
        public CstFilter<CstNewOperation> NewOperation => new CstFilter<CstNewOperation> (Children);
        public CstFilter<CstStringInterpolation> StringInterpolation => new CstFilter<CstStringInterpolation> (Children);
        public CstFilter<CstIdentifier> Identifier => new CstFilter<CstIdentifier> (Children);
    }

    /// <summary>
    /// Nodes = (HexLiteral|BinaryLiteral|FloatLiteral|IntegerLiteral|StringLiteral|CharLiteral|BooleanLiteral|NullLiteral)
    /// </summary>
    public class CstLiteral : CstChoice
    {
        public static Rule Rule = CstNodeFactory.Grammar.Literal;
        public CstLiteral(params CstNode[] children) : base(children) { }
        public CstFilter<CstHexLiteral> HexLiteral => new CstFilter<CstHexLiteral> (Children);
        public CstFilter<CstBinaryLiteral> BinaryLiteral => new CstFilter<CstBinaryLiteral> (Children);
        public CstFilter<CstFloatLiteral> FloatLiteral => new CstFilter<CstFloatLiteral> (Children);
        public CstFilter<CstIntegerLiteral> IntegerLiteral => new CstFilter<CstIntegerLiteral> (Children);
        public CstFilter<CstStringLiteral> StringLiteral => new CstFilter<CstStringLiteral> (Children);
        public CstFilter<CstCharLiteral> CharLiteral => new CstFilter<CstCharLiteral> (Children);
        public CstFilter<CstBooleanLiteral> BooleanLiteral => new CstFilter<CstBooleanLiteral> (Children);
        public CstFilter<CstNullLiteral> NullLiteral => new CstFilter<CstNullLiteral> (Children);
    }

    /// <summary>
    /// Nodes = Identifier
    /// </summary>
    public class CstMemberAccess : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.MemberAccess;
        public CstMemberAccess(params CstNode[] children) : base(children) { }
        public CstFilter<CstIdentifier> Identifier => new CstFilter<CstIdentifier> (Children);
    }

    /// <summary>
    /// Nodes = (DeclarationPreamble+(ConstructorDeclaration|MethodDeclaration|IndexerDeclaration|PropertyDeclaration|FieldDeclaration|OperatorDeclaration|ConverterDeclaration|TypeDeclaration))
    /// </summary>
    public class CstMemberDeclaration : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.MemberDeclaration;
        public CstMemberDeclaration(params CstNode[] children) : base(children) { }
        public CstFilter<CstDeclarationPreamble> DeclarationPreamble => new CstFilter<CstDeclarationPreamble> (Children);
        public CstFilter<CstConstructorDeclaration> ConstructorDeclaration => new CstFilter<CstConstructorDeclaration> (Children);
        public CstFilter<CstMethodDeclaration> MethodDeclaration => new CstFilter<CstMethodDeclaration> (Children);
        public CstFilter<CstIndexerDeclaration> IndexerDeclaration => new CstFilter<CstIndexerDeclaration> (Children);
        public CstFilter<CstPropertyDeclaration> PropertyDeclaration => new CstFilter<CstPropertyDeclaration> (Children);
        public CstFilter<CstFieldDeclaration> FieldDeclaration => new CstFilter<CstFieldDeclaration> (Children);
        public CstFilter<CstOperatorDeclaration> OperatorDeclaration => new CstFilter<CstOperatorDeclaration> (Children);
        public CstFilter<CstConverterDeclaration> ConverterDeclaration => new CstFilter<CstConverterDeclaration> (Children);
        public CstFilter<CstTypeDeclaration> TypeDeclaration => new CstFilter<CstTypeDeclaration> (Children);
    }

    /// <summary>
    /// Nodes = (TypeExpr+Identifier+FunctionParameterList+FunctionBody)
    /// </summary>
    public class CstMethodDeclaration : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.MethodDeclaration;
        public CstMethodDeclaration(params CstNode[] children) : base(children) { }
        public CstFilter<CstTypeExpr> TypeExpr => new CstFilter<CstTypeExpr> (Children);
        public CstFilter<CstIdentifier> Identifier => new CstFilter<CstIdentifier> (Children);
        public CstFilter<CstFunctionParameterList> FunctionParameterList => new CstFilter<CstFunctionParameterList> (Children);
        public CstFilter<CstFunctionBody> FunctionBody => new CstFilter<CstFunctionBody> (Children);
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstModifier : CstLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.Modifier;
        public CstModifier(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = Expression
    /// </summary>
    public class CstNameOf : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.NameOf;
        public CstNameOf(params CstNode[] children) : base(children) { }
        public CstFilter<CstExpression> Expression => new CstFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Nodes = (QualifiedIdentifier+((UsingDirective|TypeDeclarationWithPreamble))*)
    /// </summary>
    public class CstNamespaceDeclaration : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.NamespaceDeclaration;
        public CstNamespaceDeclaration(params CstNode[] children) : base(children) { }
        public CstFilter<CstQualifiedIdentifier> QualifiedIdentifier => new CstFilter<CstQualifiedIdentifier> (Children);
        public CstFilter<CstUsingDirective> UsingDirective => new CstFilter<CstUsingDirective> (Children);
        public CstFilter<CstTypeDeclarationWithPreamble> TypeDeclarationWithPreamble => new CstFilter<CstTypeDeclarationWithPreamble> (Children);
    }

    /// <summary>
    /// Nodes = ((TypeExpr)?+(FunctionArgs)?+(ArraySizeSpecifier)?+(Initializer)?)
    /// </summary>
    public class CstNewOperation : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.NewOperation;
        public CstNewOperation(params CstNode[] children) : base(children) { }
        public CstFilter<CstTypeExpr> TypeExpr => new CstFilter<CstTypeExpr> (Children);
        public CstFilter<CstFunctionArgs> FunctionArgs => new CstFilter<CstFunctionArgs> (Children);
        public CstFilter<CstArraySizeSpecifier> ArraySizeSpecifier => new CstFilter<CstArraySizeSpecifier> (Children);
        public CstFilter<CstInitializer> Initializer => new CstFilter<CstInitializer> (Children);
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstNullable : CstLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.Nullable;
        public CstNullable(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstNullLiteral : CstLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.NullLiteral;
        public CstNullLiteral(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = (TypeExpr+OverloadableOperator+FunctionParameterList+FunctionBody)
    /// </summary>
    public class CstOperatorDeclaration : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.OperatorDeclaration;
        public CstOperatorDeclaration(params CstNode[] children) : base(children) { }
        public CstFilter<CstTypeExpr> TypeExpr => new CstFilter<CstTypeExpr> (Children);
        public CstFilter<CstOverloadableOperator> OverloadableOperator => new CstFilter<CstOverloadableOperator> (Children);
        public CstFilter<CstFunctionParameterList> FunctionParameterList => new CstFilter<CstFunctionParameterList> (Children);
        public CstFilter<CstFunctionBody> FunctionBody => new CstFilter<CstFunctionBody> (Children);
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstOverloadableOperator : CstLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.OverloadableOperator;
        public CstOverloadableOperator(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = (Expression)*
    /// </summary>
    public class CstParenthesizedExpression : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.ParenthesizedExpression;
        public CstParenthesizedExpression(params CstNode[] children) : base(children) { }
        public CstFilter<CstExpression> Expression => new CstFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Nodes = (Element)*
    /// </summary>
    public class CstParenthesizedStructure : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.ParenthesizedStructure;
        public CstParenthesizedStructure(params CstNode[] children) : base(children) { }
        public CstFilter<CstElement> Element => new CstFilter<CstElement> (Children);
    }

    /// <summary>
    /// Nodes = (MemberAccess|ConditionalMemberAccess|FunctionArgs|Indexer|TernaryOperation|BinaryOperation|IsOperation|AsOperation)
    /// </summary>
    public class CstPostfixOperator : CstChoice
    {
        public static Rule Rule = CstNodeFactory.Grammar.PostfixOperator;
        public CstPostfixOperator(params CstNode[] children) : base(children) { }
        public CstFilter<CstMemberAccess> MemberAccess => new CstFilter<CstMemberAccess> (Children);
        public CstFilter<CstConditionalMemberAccess> ConditionalMemberAccess => new CstFilter<CstConditionalMemberAccess> (Children);
        public CstFilter<CstFunctionArgs> FunctionArgs => new CstFilter<CstFunctionArgs> (Children);
        public CstFilter<CstIndexer> Indexer => new CstFilter<CstIndexer> (Children);
        public CstFilter<CstTernaryOperation> TernaryOperation => new CstFilter<CstTernaryOperation> (Children);
        public CstFilter<CstBinaryOperation> BinaryOperation => new CstFilter<CstBinaryOperation> (Children);
        public CstFilter<CstIsOperation> IsOperation => new CstFilter<CstIsOperation> (Children);
        public CstFilter<CstAsOperation> AsOperation => new CstFilter<CstAsOperation> (Children);
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstPrefixOperator : CstLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.PrefixOperator;
        public CstPrefixOperator(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = (PropertyExpression|PropertyWithClauses)
    /// </summary>
    public class CstPropertyBody : CstChoice
    {
        public static Rule Rule = CstNodeFactory.Grammar.PropertyBody;
        public CstPropertyBody(params CstNode[] children) : base(children) { }
        public CstFilter<CstPropertyExpression> PropertyExpression => new CstFilter<CstPropertyExpression> (Children);
        public CstFilter<CstPropertyWithClauses> PropertyWithClauses => new CstFilter<CstPropertyWithClauses> (Children);
    }

    /// <summary>
    /// Nodes = ((Getter|Setter|Initter))+
    /// </summary>
    public class CstPropertyClauses : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.PropertyClauses;
        public CstPropertyClauses(params CstNode[] children) : base(children) { }
        public CstFilter<CstGetter> Getter => new CstFilter<CstGetter> (Children);
        public CstFilter<CstSetter> Setter => new CstFilter<CstSetter> (Children);
        public CstFilter<CstInitter> Initter => new CstFilter<CstInitter> (Children);
    }

    /// <summary>
    /// Nodes = (TypeExpr+Identifier+PropertyBody)
    /// </summary>
    public class CstPropertyDeclaration : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.PropertyDeclaration;
        public CstPropertyDeclaration(params CstNode[] children) : base(children) { }
        public CstFilter<CstTypeExpr> TypeExpr => new CstFilter<CstTypeExpr> (Children);
        public CstFilter<CstIdentifier> Identifier => new CstFilter<CstIdentifier> (Children);
        public CstFilter<CstPropertyBody> PropertyBody => new CstFilter<CstPropertyBody> (Children);
    }

    /// <summary>
    /// Nodes = ExpressionBody
    /// </summary>
    public class CstPropertyExpression : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.PropertyExpression;
        public CstPropertyExpression(params CstNode[] children) : base(children) { }
        public CstFilter<CstExpressionBody> ExpressionBody => new CstFilter<CstExpressionBody> (Children);
    }

    /// <summary>
    /// Nodes = (PropertyClauses+(Initialization)?)
    /// </summary>
    public class CstPropertyWithClauses : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.PropertyWithClauses;
        public CstPropertyWithClauses(params CstNode[] children) : base(children) { }
        public CstFilter<CstPropertyClauses> PropertyClauses => new CstFilter<CstPropertyClauses> (Children);
        public CstFilter<CstInitialization> Initialization => new CstFilter<CstInitialization> (Children);
    }

    /// <summary>
    /// Nodes = (Identifier)*
    /// </summary>
    public class CstQualifiedIdentifier : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.QualifiedIdentifier;
        public CstQualifiedIdentifier(params CstNode[] children) : base(children) { }
        public CstFilter<CstIdentifier> Identifier => new CstFilter<CstIdentifier> (Children);
    }

    /// <summary>
    /// Nodes = (Expression)?
    /// </summary>
    public class CstReturnStatement : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.ReturnStatement;
        public CstReturnStatement(params CstNode[] children) : base(children) { }
        public CstFilter<CstExpression> Expression => new CstFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Nodes = (TypeDirectiveOrStatement)*
    /// </summary>
    public class CstScript : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.Script;
        public CstScript(params CstNode[] children) : base(children) { }
        public CstFilter<CstTypeDirectiveOrStatement> TypeDirectiveOrStatement => new CstFilter<CstTypeDirectiveOrStatement> (Children);
    }

    /// <summary>
    /// Nodes = (TypeKeyword|StatementKeyword)
    /// </summary>
    public class CstSeparator : CstChoice
    {
        public static Rule Rule = CstNodeFactory.Grammar.Separator;
        public CstSeparator(params CstNode[] children) : base(children) { }
        public CstFilter<CstTypeKeyword> TypeKeyword => new CstFilter<CstTypeKeyword> (Children);
        public CstFilter<CstStatementKeyword> StatementKeyword => new CstFilter<CstStatementKeyword> (Children);
    }

    /// <summary>
    /// Nodes = FunctionBody
    /// </summary>
    public class CstSetter : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.Setter;
        public CstSetter(params CstNode[] children) : base(children) { }
        public CstFilter<CstFunctionBody> FunctionBody => new CstFilter<CstFunctionBody> (Children);
    }

    /// <summary>
    /// Nodes = QualifiedIdentifier
    /// </summary>
    public class CstSimpleTypExpr : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.SimpleTypExpr;
        public CstSimpleTypExpr(params CstNode[] children) : base(children) { }
        public CstFilter<CstQualifiedIdentifier> QualifiedIdentifier => new CstFilter<CstQualifiedIdentifier> (Children);
    }

    /// <summary>
    /// Nodes = (((UsingDirective)*+(NamespaceDeclaration)?))*
    /// </summary>
    public class CstFile : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.File;
        public CstFile(params CstNode[] children) : base(children) { }
        public CstFilter<CstUsingDirective> UsingDirective => new CstFilter<CstUsingDirective> (Children);
        public CstFilter<CstNamespaceDeclaration> NamespaceDeclaration => new CstFilter<CstNamespaceDeclaration> (Children);
    }

    /// <summary>
    /// Nodes = (CompoundStatement|IfStatement|WhileStatement|DoWhileStatement|ReturnStatement|BreakStatement|ContinueStatement|ForStatement|ForEachStatement|FunctionDeclStatement|VarDeclStatement|TryStatement|YieldStatement|SwitchStatement|ExpressionStatement)
    /// </summary>
    public class CstStatement : CstChoice
    {
        public static Rule Rule = CstNodeFactory.Grammar.Statement;
        public CstStatement(params CstNode[] children) : base(children) { }
        public CstFilter<CstCompoundStatement> CompoundStatement => new CstFilter<CstCompoundStatement> (Children);
        public CstFilter<CstIfStatement> IfStatement => new CstFilter<CstIfStatement> (Children);
        public CstFilter<CstWhileStatement> WhileStatement => new CstFilter<CstWhileStatement> (Children);
        public CstFilter<CstDoWhileStatement> DoWhileStatement => new CstFilter<CstDoWhileStatement> (Children);
        public CstFilter<CstReturnStatement> ReturnStatement => new CstFilter<CstReturnStatement> (Children);
        public CstFilter<CstBreakStatement> BreakStatement => new CstFilter<CstBreakStatement> (Children);
        public CstFilter<CstContinueStatement> ContinueStatement => new CstFilter<CstContinueStatement> (Children);
        public CstFilter<CstForStatement> ForStatement => new CstFilter<CstForStatement> (Children);
        public CstFilter<CstForEachStatement> ForEachStatement => new CstFilter<CstForEachStatement> (Children);
        public CstFilter<CstFunctionDeclStatement> FunctionDeclStatement => new CstFilter<CstFunctionDeclStatement> (Children);
        public CstFilter<CstVarDeclStatement> VarDeclStatement => new CstFilter<CstVarDeclStatement> (Children);
        public CstFilter<CstTryStatement> TryStatement => new CstFilter<CstTryStatement> (Children);
        public CstFilter<CstYieldStatement> YieldStatement => new CstFilter<CstYieldStatement> (Children);
        public CstFilter<CstSwitchStatement> SwitchStatement => new CstFilter<CstSwitchStatement> (Children);
        public CstFilter<CstExpressionStatement> ExpressionStatement => new CstFilter<CstExpressionStatement> (Children);
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstStatementKeyword : CstLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.StatementKeyword;
        public CstStatementKeyword(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = (StatementKeyword+TokenGroup+(BracedStructure)?)
    /// </summary>
    public class CstStatementStructure : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.StatementStructure;
        public CstStatementStructure(params CstNode[] children) : base(children) { }
        public CstFilter<CstStatementKeyword> StatementKeyword => new CstFilter<CstStatementKeyword> (Children);
        public CstFilter<CstTokenGroup> TokenGroup => new CstFilter<CstTokenGroup> (Children);
        public CstFilter<CstBracedStructure> BracedStructure => new CstFilter<CstBracedStructure> (Children);
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstStatic : CstLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.Static;
        public CstStatic(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = (StringInterpolationContent)*
    /// </summary>
    public class CstStringInterpolation : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.StringInterpolation;
        public CstStringInterpolation(params CstNode[] children) : base(children) { }
        public CstFilter<CstStringInterpolationContent> StringInterpolationContent => new CstFilter<CstStringInterpolationContent> (Children);
    }

    /// <summary>
    /// Nodes = Expression
    /// </summary>
    public class CstStringInterpolationContent : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.StringInterpolationContent;
        public CstStringInterpolationContent(params CstNode[] children) : base(children) { }
        public CstFilter<CstExpression> Expression => new CstFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstStringLiteral : CstLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.StringLiteral;
        public CstStringLiteral(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = (BracketedStructure|ParenthesizedStructure|BracedStructure)
    /// </summary>
    public class CstStructure : CstChoice
    {
        public static Rule Rule = CstNodeFactory.Grammar.Structure;
        public CstStructure(params CstNode[] children) : base(children) { }
        public CstFilter<CstBracketedStructure> BracketedStructure => new CstFilter<CstBracketedStructure> (Children);
        public CstFilter<CstParenthesizedStructure> ParenthesizedStructure => new CstFilter<CstParenthesizedStructure> (Children);
        public CstFilter<CstBracedStructure> BracedStructure => new CstFilter<CstBracedStructure> (Children);
    }

    /// <summary>
    /// Nodes = (CaseClause)*
    /// </summary>
    public class CstSwitchStatement : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.SwitchStatement;
        public CstSwitchStatement(params CstNode[] children) : base(children) { }
        public CstFilter<CstCaseClause> CaseClause => new CstFilter<CstCaseClause> (Children);
    }

    /// <summary>
    /// Nodes = (Expression+Expression)
    /// </summary>
    public class CstTernaryOperation : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.TernaryOperation;
        public CstTernaryOperation(params CstNode[] children) : base(children) { }
        public CstFilter<CstExpression> Expression => new CstFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Nodes = ParenthesizedExpression
    /// </summary>
    public class CstThisCall : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.ThisCall;
        public CstThisCall(params CstNode[] children) : base(children) { }
        public CstFilter<CstParenthesizedExpression> ParenthesizedExpression => new CstFilter<CstParenthesizedExpression> (Children);
    }

    /// <summary>
    /// Nodes = Expression
    /// </summary>
    public class CstThrowExpression : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.ThrowExpression;
        public CstThrowExpression(params CstNode[] children) : base(children) { }
        public CstFilter<CstExpression> Expression => new CstFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Nodes = (Separator|Identifier|Literal)
    /// </summary>
    public class CstToken : CstChoice
    {
        public static Rule Rule = CstNodeFactory.Grammar.Token;
        public CstToken(params CstNode[] children) : base(children) { }
        public CstFilter<CstSeparator> Separator => new CstFilter<CstSeparator> (Children);
        public CstFilter<CstIdentifier> Identifier => new CstFilter<CstIdentifier> (Children);
        public CstFilter<CstLiteral> Literal => new CstFilter<CstLiteral> (Children);
    }

    /// <summary>
    /// Nodes = ((Token|Separator))+
    /// </summary>
    public class CstTokenGroup : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.TokenGroup;
        public CstTokenGroup(params CstNode[] children) : base(children) { }
        public CstFilter<CstToken> Token => new CstFilter<CstToken> (Children);
        public CstFilter<CstSeparator> Separator => new CstFilter<CstSeparator> (Children);
    }

    /// <summary>
    /// Nodes = (CompoundStatement+(CatchClause)?+(FinallyClause)?)
    /// </summary>
    public class CstTryStatement : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.TryStatement;
        public CstTryStatement(params CstNode[] children) : base(children) { }
        public CstFilter<CstCompoundStatement> CompoundStatement => new CstFilter<CstCompoundStatement> (Children);
        public CstFilter<CstCatchClause> CatchClause => new CstFilter<CstCatchClause> (Children);
        public CstFilter<CstFinallyClause> FinallyClause => new CstFilter<CstFinallyClause> (Children);
    }

    /// <summary>
    /// Nodes = (TypeExpr)*
    /// </summary>
    public class CstTypeArgList : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.TypeArgList;
        public CstTypeArgList(params CstNode[] children) : base(children) { }
        public CstFilter<CstTypeExpr> TypeExpr => new CstFilter<CstTypeExpr> (Children);
    }

    /// <summary>
    /// Nodes = (Kind+Identifier+TypeParameterList+BaseClassList+ConstraintList+(MemberDeclaration)*)
    /// </summary>
    public class CstTypeDeclaration : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.TypeDeclaration;
        public CstTypeDeclaration(params CstNode[] children) : base(children) { }
        public CstFilter<CstKind> Kind => new CstFilter<CstKind> (Children);
        public CstFilter<CstIdentifier> Identifier => new CstFilter<CstIdentifier> (Children);
        public CstFilter<CstTypeParameterList> TypeParameterList => new CstFilter<CstTypeParameterList> (Children);
        public CstFilter<CstBaseClassList> BaseClassList => new CstFilter<CstBaseClassList> (Children);
        public CstFilter<CstConstraintList> ConstraintList => new CstFilter<CstConstraintList> (Children);
        public CstFilter<CstMemberDeclaration> MemberDeclaration => new CstFilter<CstMemberDeclaration> (Children);
    }

    /// <summary>
    /// Nodes = (DeclarationPreamble+TypeDeclaration)
    /// </summary>
    public class CstTypeDeclarationWithPreamble : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.TypeDeclarationWithPreamble;
        public CstTypeDeclarationWithPreamble(params CstNode[] children) : base(children) { }
        public CstFilter<CstDeclarationPreamble> DeclarationPreamble => new CstFilter<CstDeclarationPreamble> (Children);
        public CstFilter<CstTypeDeclaration> TypeDeclaration => new CstFilter<CstTypeDeclaration> (Children);
    }

    /// <summary>
    /// Nodes = (UsingDirective|TypeDeclarationWithPreamble|Statement)
    /// </summary>
    public class CstTypeDirectiveOrStatement : CstChoice
    {
        public static Rule Rule = CstNodeFactory.Grammar.TypeDirectiveOrStatement;
        public CstTypeDirectiveOrStatement(params CstNode[] children) : base(children) { }
        public CstFilter<CstUsingDirective> UsingDirective => new CstFilter<CstUsingDirective> (Children);
        public CstFilter<CstTypeDeclarationWithPreamble> TypeDeclarationWithPreamble => new CstFilter<CstTypeDeclarationWithPreamble> (Children);
        public CstFilter<CstStatement> Statement => new CstFilter<CstStatement> (Children);
    }

    /// <summary>
    /// Nodes = InnerTypeExpr
    /// </summary>
    public class CstTypeExpr : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.TypeExpr;
        public CstTypeExpr(params CstNode[] children) : base(children) { }
        public CstFilter<CstInnerTypeExpr> InnerTypeExpr => new CstFilter<CstInnerTypeExpr> (Children);
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstTypeKeyword : CstLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.TypeKeyword;
        public CstTypeKeyword(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = TypeExpr
    /// </summary>
    public class CstTypeOf : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.TypeOf;
        public CstTypeOf(params CstNode[] children) : base(children) { }
        public CstFilter<CstTypeExpr> TypeExpr => new CstFilter<CstTypeExpr> (Children);
    }

    /// <summary>
    /// Nodes = (TypeVariance+Identifier)
    /// </summary>
    public class CstTypeParameter : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.TypeParameter;
        public CstTypeParameter(params CstNode[] children) : base(children) { }
        public CstFilter<CstTypeVariance> TypeVariance => new CstFilter<CstTypeVariance> (Children);
        public CstFilter<CstIdentifier> Identifier => new CstFilter<CstIdentifier> (Children);
    }

    /// <summary>
    /// Nodes = (TypeParameter)*
    /// </summary>
    public class CstTypeParameterList : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.TypeParameterList;
        public CstTypeParameterList(params CstNode[] children) : base(children) { }
        public CstFilter<CstTypeParameter> TypeParameter => new CstFilter<CstTypeParameter> (Children);
    }

    /// <summary>
    /// Nodes = (TypeKeyword+TokenGroup+BracedStructure)
    /// </summary>
    public class CstTypeStructure : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.TypeStructure;
        public CstTypeStructure(params CstNode[] children) : base(children) { }
        public CstFilter<CstTypeKeyword> TypeKeyword => new CstFilter<CstTypeKeyword> (Children);
        public CstFilter<CstTokenGroup> TokenGroup => new CstFilter<CstTokenGroup> (Children);
        public CstFilter<CstBracedStructure> BracedStructure => new CstFilter<CstBracedStructure> (Children);
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstTypeVariance : CstLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.TypeVariance;
        public CstTypeVariance(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = (Static+QualifiedIdentifier+(QualifiedIdentifier)?)
    /// </summary>
    public class CstUsingDirective : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.UsingDirective;
        public CstUsingDirective(params CstNode[] children) : base(children) { }
        public CstFilter<CstStatic> Static => new CstFilter<CstStatic> (Children);
        public CstFilter<CstQualifiedIdentifier> QualifiedIdentifier => new CstFilter<CstQualifiedIdentifier> (Children);
    }

    /// <summary>
    /// Nodes = (TypeExpr+(VarWithInitialization)+)
    /// </summary>
    public class CstVarDecl : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.VarDecl;
        public CstVarDecl(params CstNode[] children) : base(children) { }
        public CstFilter<CstTypeExpr> TypeExpr => new CstFilter<CstTypeExpr> (Children);
        public CstFilter<CstVarWithInitialization> VarWithInitialization => new CstFilter<CstVarWithInitialization> (Children);
    }

    /// <summary>
    /// Nodes = VarDecl
    /// </summary>
    public class CstVarDeclStatement : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.VarDeclStatement;
        public CstVarDeclStatement(params CstNode[] children) : base(children) { }
        public CstFilter<CstVarDecl> VarDecl => new CstFilter<CstVarDecl> (Children);
    }

    /// <summary>
    /// Nodes = (Identifier+Initialization)
    /// </summary>
    public class CstVarWithInitialization : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.VarWithInitialization;
        public CstVarWithInitialization(params CstNode[] children) : base(children) { }
        public CstFilter<CstIdentifier> Identifier => new CstFilter<CstIdentifier> (Children);
        public CstFilter<CstInitialization> Initialization => new CstFilter<CstInitialization> (Children);
    }

    /// <summary>
    /// Nodes = (ParenthesizedExpression+Statement)
    /// </summary>
    public class CstWhileStatement : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.WhileStatement;
        public CstWhileStatement(params CstNode[] children) : base(children) { }
        public CstFilter<CstParenthesizedExpression> ParenthesizedExpression => new CstFilter<CstParenthesizedExpression> (Children);
        public CstFilter<CstStatement> Statement => new CstFilter<CstStatement> (Children);
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstYieldBreak : CstLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.YieldBreak;
        public CstYieldBreak(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = Expression
    /// </summary>
    public class CstYieldReturn : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.YieldReturn;
        public CstYieldReturn(params CstNode[] children) : base(children) { }
        public CstFilter<CstExpression> Expression => new CstFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Nodes = (YieldReturn|YieldBreak)
    /// </summary>
    public class CstYieldStatement : CstChoice
    {
        public static Rule Rule = CstNodeFactory.Grammar.YieldStatement;
        public CstYieldStatement(params CstNode[] children) : base(children) { }
        public CstFilter<CstYieldReturn> YieldReturn => new CstFilter<CstYieldReturn> (Children);
        public CstFilter<CstYieldBreak> YieldBreak => new CstFilter<CstYieldBreak> (Children);
    }

}
